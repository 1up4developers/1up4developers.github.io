<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: quick tips | 1up4developers]]></title>
  <link href="http://1up4dev.org/categories/quick-tips/atom.xml" rel="self"/>
  <link href="http://1up4dev.org/"/>
  <updated>2016-07-12T11:26:29-03:00</updated>
  <id>http://1up4dev.org/</id>
  <author>
    <name><![CDATA[1up4developers]]></name>
    <email><![CDATA[1up4dev@googlegroups.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fazendo mágica com o REPL do Clojure]]></title>
    <link href="http://1up4dev.org/2014/09/magica-com-o-repl-do-clojure/"/>
    <updated>2014-09-23T18:24:00-03:00</updated>
    <id>http://1up4dev.org/2014/09/magica-com-o-repl-do-clojure</id>
    <content type="html"><![CDATA[<p>Caso você não esteja íntimo com o REPL do Clojure, recomendo a leitura do <a href="http://1up4dev.org/2014/04/alguns-truques-com-o-repl-do-clojure/">texto anterior</a> para aprender o básico.</p>

<p>É recomendado também que você leia as mensagens emitidas pela aplicação com a voz do <a href="http://pt.wikipedia.org/wiki/Cid_Moreira">Cid Moreira</a>. Para uma versão em inglês do artigo estou considerando sugerir as vozes do Morgan Freeman ou do Stephen Fry.</p>

<p>As pessoas me perguntam se um REPL é equivalente ao IRB do Ruby ou o modo interativo do Python. No artigo anterior eu comentei que o REPL é bem mais do que isso, mas ainda não fui convincente o bastante.</p>

<p>Nesse artigo eu pretendo demonstrar como podemos modificar a aplicação enquanto ela é executada, sem necessidade de reiniciá-la ou de esperar para que a compilação termine.</p>

<p>Primeiro, vamos instalar uma ferramenta chamada <strong>Leiningen</strong>, que pode ser facilmente instalada a partir de <a href="http://leiningen.org/#install.">http://leiningen.org/#install.</a></p>

<p>O <strong>Leiningen</strong> é uma ferramenta que automatiza uma série de processos cotidianos do desenvolvimento de uma aplicação, além de também cuidar das dependências da aplicação. Pense nele como um primo bonito do <strong>Maven</strong> ou do <strong>Gradle</strong>.</p>

<p>Primeiro, vamos criar uma aplicação usando o <strong>Leiningen</strong>.</p>

<p>No terminal, digite:</p>

<pre><code>lein new misterm
</code></pre>

<p>Se for a primeira vez que você utiliza o <strong>Leiningen</strong>, algumas dependências serão baixadas para a sua máquina.</p>

<pre><code>$ lein new misterm
Generating a project called misterm based on the 'default' template.
The default template is intended for library projects, not applications.
To see other templates (app, plugin, etc), try `lein help new`.
</code></pre>

<p>Será criado um diretório chamado <code>misterm</code>, onde teremos nossa aplicação, e dentro desse diretório, edite um arquivo <code>project.clj</code>.</p>

<pre><code>; O seu arquivo project.clj vai ter essa cara
(defproject misterm "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]])
</code></pre>

<p>O conteúdo do arquivo <code>project.clj</code> nada mais é do que um código Clojure válido, sendo <code>defproject</code> uma <strong>macro</strong> que armazena as configurações do projeto em algum estado global. Vou deixar para explicar macros em outro artigo.</p>

<p>Para que a mágica funcione, vamos adicionar o <code>nREPL</code> na nossa aplicação. <code>nREPL</code> é uma biblioteca que permite que o REPL do Clojure seja acessado remotamente, normalmente através de uma porta TCP. O próprio REPL do Clojure disponibilizado pelo Leiningen já vem com o nREPL, como vamos ver mais para frente.</p>

<p>Para criarmos um projeto executável, precisamos informar no projeto em qual <strong>namespace</strong> estará o <strong>entrypoint</strong> da aplicação. Pense num <strong>namespace</strong> como um <strong>package</strong> do Java, apesar de existirem grandes diferenças entre ambos. Para a nossa explicação, considerar um como o outro basta.</p>

<p>Vamos editar o arquivo, adicionando a nova dependência dentro do vetor <code>:dependencies</code> e também a opção <code>:main misterm.core</code> antes do parêntese final.</p>

<p>O final do arquivo vai ficar assim:</p>

<pre><code>; final do arquivo project.clj
  :dependencies [[org.clojure/clojure "1.6.0"]
                 [org.clojure/tools.nrepl "0.2.5"]]
  :main misterm.core)
</code></pre>

<p>Agora vamos editar o arquivo <code>core.clj</code>, que está dentro de <code>src/misterm</code>. Perceba que o nome da aplicação é usado por padrão como parte do nome do <strong>namespace</strong>.</p>

<p>Encontraremos um arquivo assim:</p>

<pre><code>(ns misterm.core)

(defn foo
  "I don't do a whole lot."
  [x]
  (println x "Hello, World!"))
</code></pre>

<p>Aqui está sendo declarado o <strong>namespace</strong> <code>misterm.core</code>, e em seguida uma função <code>foo</code> que simplesmente imprime o texto <strong>Hello, World!</strong>.</p>

<p>Vamos modificar a declaração do <strong>namespace</strong> para que possamos usar o <code>nREPL</code> em nossa aplicação.</p>

<pre><code>(ns misterm.core
    (:require [clojure.tools.nrepl.server :as nrepl]))
</code></pre>

<p>Em seguida vamos iniciar o servidor do <code>nREPL</code> na porta 12345.</p>

<pre><code>(defonce server (nrepl/start-server :port 12345))
</code></pre>

<p>Estamos usando <code>defonce</code> aqui para garantir que, ao acessarmos a aplicação via <code>nREPL</code>, o servidor não seja iniciado mais de uma vez. Caso isso aconteça teremos um erro porque a porta 12345 já estará em uso.</p>

<p>Vamos apagar a função <code>foo</code> e vamos criar uma chamada <code>magic</code>:</p>

<pre><code>(defn magica []
  (Thread/sleep 2000)
  (println "Mostre-nos o seu segredo, Mister M"))
</code></pre>

<p>Nossa função simplesmente espera dois segundos e, sem seguida, imprime na tela um texto.</p>

<p>Agora vamos criar a função <code>-main</code>, que serve como <strong>entrypoint</strong> da aplicação, assim como o método <code>main</code> de uma aplicação Java.</p>

<pre><code>(defn -main [&amp; args]
  (loop []
    (magica)
    (recur)))
</code></pre>

<p>O argumento <code>&amp; args</code> indica que a função <code>-main</code> aceita uma quantidade indefinida de parâmetros, ou mesmo nenhum, exatamente como acontece com o método <code>main(String ... args)</code> do Java.</p>

<p>Os operadores <code>loop</code> e <code>recur</code> são usados para simularmos <strong>tail call recursion</strong> no Clojure, o que é assunto para outro texto. Para o que precisamos, basta saber que criamos um loop infinito com eles. Dentro desse loop infinito estamos invocando a função <code>magica</code>.</p>

<p>Tudo pronto, vamos salvar o arquivo e voltar para o terminal. Execute o comando <code>lein run</code> para executar a aplicação e a cada dois segundos será exibida a mensagem. Lembre-se de usar a voz do Cid Moreira ao ler.</p>

<pre><code>$ lein run
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
</code></pre>

<p>Vamos abrir um novo terminal e executar o comando <code>lein repl :connect 127.0.0.1:12345</code>.</p>

<pre><code>$ lein repl :connect 127.0.0.1:12345
Connecting to nREPL at 127.0.0.1:12345
REPL-y 0.3.5, nREPL 0.2.6
Clojure 1.6.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0-b132
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=&gt;
</code></pre>

<p>O prompt indica que estamos no namespace padrão do Clojure, chamado <code>user</code>. Vamos para o namespace onde estão as nossas funções para verificar se estamos mesmo conectados na aplicação.</p>

<pre><code>(ns misterm.core)
</code></pre>

<p>Agora vamos executar a função <code>magica</code>. Se tudo foi feito corretamente até agora, vamos esperar dois minutos e então ler a mensagem <strong>Mostre-nos o seu segredo, Mister M</strong>.</p>

<pre><code>(magica)
; Mostre-nos o seu segredo, Mister M
</code></pre>

<p>Tudo certo. Agora vamos modificar a aplicação enquanto ela está sendo executada.</p>

<p>Dê uma olhada no primeiro terminal. A essa altura a nossa mensagem já encheu a tela.</p>

<p>De volta ao segundo terminal, o que está com o REPL aberto, reescreva o conteúdo da função <code>magica</code>:</p>

<pre><code>(defn magica []
  (Thread/sleep 1000)
  (println "Aaaaaahhhhh, Mister M!"))
</code></pre>

<p>A função <code>magica</code> já existia, mas estamos redefinindo em tempo de execução. Se você tentar fazer isso no IRB, por exemplo, receberá uma mensagem de erro.</p>

<p>Agora olhe novamente no primeiro terminal, aquele que estava com a tela cheia de mensagens.</p>

<pre><code>Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Aaaaaahhhhh, Mister M!
Aaaaaahhhhh, Mister M!
Aaaaaahhhhh, Mister M!
</code></pre>

<p>A mensagem mudou! Não só isso. Agora ela leva um segundo para ser exibida na tela, ao invés dos dois originais. Nós mudamos a aplicação enquanto ela estava sendo executada.</p>

<p>Claro que toda mágica tem lá seus pontos a serem considerados. Se você reiniciar a aplicação a mensagem original será novamente exibida, já que alteramos a aplicação enquanto ela estava sendo executada, e não seu código fonte.</p>

<p>Esse recurso é muito útil para corrigir erros sem derrubar a aplicação, para desenvolver aplicações de maneira verdadeiramente incremental e iterativa, e também para aumentarmos a velocidade do ciclo de desenvolvimento ao máximo. Pense que dessa forma não precisamos mais derrubar a aplicação, recompilar, executar novamente, aguardar o tempo de carga da JVM, que não é pouco. Numa visão otimista, caso você ganhe dez segundos em cada iteração do seu ciclo de desenvolvimento, ao final do dia você terá economizado muito tempo, além de ter mantido o foco naquilo que realmente importa. É sabido que essas mudanças de contexto, por mais rápidas que sejam, atrapalham a concentração e a produtividade.</p>

<p>Editores como <strong>Emacs</strong> e <strong>ViM</strong> têm plugins que se conectam ao <code>nREPL</code>, fazendo com que você nem ao menos precise fechar a janela de edição de código para alterar a aplicação. Já o <strong>Lighttable</strong> oferece um modo chamado <strong>InstantREPL</strong>, onde seu código é avaliado na própria edição, exibindo os valores enquanto você programa.</p>

<p>O REPL é uma ferramenta poderosa não só no Clojure, mas em praticamente todos os dialetos LISP. Experimente fazer isso com a sua linguagem preferida e veja se consegue ter tanto ganho de produtividade.</p>

<p>P.S.: Jon Garret conseguiu inclusive corrigir um bug em um satélite em órbita graças ao uso do REPL. Leia mais <a href="http://www.flownet.com/gat/jpl-lisp.html">aqui</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Alguns truques com o REPL do Clojure]]></title>
    <link href="http://1up4dev.org/2014/04/alguns-truques-com-o-repl-do-clojure/"/>
    <updated>2014-04-25T11:21:00-03:00</updated>
    <id>http://1up4dev.org/2014/04/alguns-truques-com-o-repl-do-clojure</id>
    <content type="html"><![CDATA[<p>O <tt>REPL</tt> é uma das ferramentas mais úteis para se programar em Clojure. Se você está chegando do Ruby ou do Python está mais do que acostumado a usar o <tt>IRB</tt> ou o modo interativo do Python. Veremos no decorrer do capítulo que o REPL é bem mais do que um prompt da linguagem, que serve apenas para que instruções sejam testadas.</p>

<p>Existem alguns atalhos e funções auxiliares que tornam o uso do REPL bem mais produtivo. Por mais que escrever diretamente no REPL não seja tão confortável quando no seu editor preferido, algumas vezes isso acaba sendo necessário.</p>

<h3>Qual é mesmo o nome daquela função?</h3>

<p>As funções da biblioteca padrão do Clojure vem com um texto explicativo, onde você pode se situar sobre como utilizá-las.</p>

<p>Podemos pesquisar alguma palavra que estiver dentro desses textos para encontrar a função que queremos, mas não lembramos o nome. Para isso, usamos <tt>find-doc</tt>, seguido da palavra ou trecho de texto relacionado ao que queremos.</p>

<p>Vamos supor que eu esteja procurando algo sobre <em>sockets</em>. Basta digitar <tt>(find-doc &ldquo;socket&rdquo;)</tt> no REPL.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">find-doc </span><span class="o">&amp;</span><span class="nv">ldquo</span><span class="c1">;socket&amp;rdquo;)</span>
</span><span class='line'><span class="c1">; &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;</span>
</span><span class='line'><span class="c1">; clojure.tools.nrepl/connect</span>
</span><span class='line'><span class="c1">; ([&amp;amp; {:keys [port host transport-fn], :or {transport-fn</span>
</span><span class='line'><span class="c1">;  transport/bencode, host &amp;ldquo;localhost&amp;rdquo;}}])</span>
</span><span class='line'><span class="c1">;  Connects to a socket-based REPL at the given host (defaults to</span>
</span><span class='line'><span class="c1">;  localhost) and port, returning the Transport (by default clojure.&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="c1">; e mais um monte de coisas&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>No nosso exemplo, encontramos a função <code>connect</code>, que está no namespace <code>clojure.tools.nrepl</code>.</p>

<p>Se você lembra de alguma parte do nome da função, então pode usar a função <tt>apropos</tt>, passando como parâmetros o trecho do nome ou uma expressão regular. Não se preocupe com expressões regulares agora, pois veremos esse assunto em detalhes mais para frente.</p>

<p>Vamos supor que eu esteja manipulando vetores e não lembre o nome da função, mas saiba que a estrutura chama-se <tt>vector</tt>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nf">apropos</span> <span class="o">&amp;</span><span class="nv">ldquo</span><span class="c1">;vector&amp;rdquo;)</span>
</span><span class='line'><span class="c1">; (vector-of vector vector? vector-zip)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>E agora você pode usar a função <tt>doc</tt> para ver a documentação daquela que mais se parecer com o que você estiver procurando:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">doc </span><span class="nv">vector?</span><span class="p">)</span>
</span><span class='line'><span class="c1">; &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;</span>
</span><span class='line'><span class="c1">; clojure.core/vector?</span>
</span><span class='line'><span class="c1">; ([x])</span>
</span><span class='line'><span class="c1">;   Return true if x implements IPersistentVector&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Existe uma variação de <tt>apropos</tt> chamada <tt>apropos-better</tt>, que informa também o namespace da função quando ela não estiver dentro do namespace <tt>clojure.core</tt> ou dentro do namespace em que você estiver no momento:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nf">apropos-better</span> <span class="o">&amp;</span><span class="nv">ldquo</span><span class="c1">;vector&amp;rdquo;)</span>
</span><span class='line'><span class="c1">; (vector vector-of vector? clojure.zip/vector-zip)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>Um pouco de Bash na sua vida</h3>

<p>Quando você usa o REPL por dentro do Leiningen, alguns atalhos já conhecidos pelos usuários de Bash estão disponíveis, mesmo para quem está usando o Leiningen no Windows.</p>

<p>O primeiro deles é a tecla <em>TAB</em>, que exibe os nomes de funções que começam com o que você já digitou.</p>

<p>Por exemplo, vou digitar <tt>map</tt> e pressionar <em>TAB</em></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nf">map</span>
</span><span class='line'><span class="c1">; map           map-indexed   map?          mapcat        mapv&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Outra combinação que agiliza bastante o trabalho é a combinação <em>Control L</em>, ou <em>Command L</em> se você estiver usando MacOS, que limpa os resultados das expressões anteriores e mantém apenas a expressão que você estiver digitando no momento.</p>

<p>Existe também a combinação <em>Control R</em>, ou <em>Command R</em>, que completa o que você estiver digitando usando o histórico de comandos do REPL. Pressionando essa combinação mais de uma vez vai alternar entre todas as combinações já utilizadas que contenham o texto que você já digitou.</p>

<p>Usar as setas <em>para cima</em> ou <em>para baixo</em> permite que você navegue nos comandos utilizados recentemente.</p>

<h3>Recuperando os últimos resultados</h3>

<p>Existem também símbolos especiais que guardam os resultados das últimas expressões e exceções. Eles são <tt><em>1</tt>, <tt></em>2</tt> e <tt><em>3</tt> para os valores e <tt></em>e</tt> para a última exceção, ou erro, que ocorreu:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="c1">; 3&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">4</span><span class="p">)</span>
</span><span class='line'><span class="c1">; 8&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">/ </span><span class="mi">8</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="c1">; 4&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">println </span><span class="o">&amp;</span><span class="nv">ldquo</span><span class="c1">;Resultados anteriores:&amp;rdquo; &lt;em&gt;1 &lt;/em&gt;2 *3)</span>
</span><span class='line'><span class="c1">; Resultados anteriores: 4 8 3&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">/ </span><span class="mi">1</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="c1">; ArithmeticException Divide by zero&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">println </span><span class="o">&amp;</span><span class="nv">ldquo</span><span class="c1">;Último erro:&amp;rdquo; *e)</span>
</span><span class='line'><span class="c1">; Último erro: #&lt;ArithmeticException java.lang.ArithmeticException:</span>
</span><span class='line'><span class="c1">;   Divide by zero&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>Consultando o código fonte</h3>

<p>Algumas vezes é bom ter acesso ao código fonte de determinada função ou macro para que possamos entender melhor como ela funciona. Enquanto eu escrevia este artigo, fiz isso constantemente para descobrir como as coisas funcionam por baixo dos panos.</p>

<p>Infelizmente, nem sempre é simples ir até o site onde o código fonte do Clojure está disponível e procurar o arquivo em que aquela função está definida.</p>

<p>Pior ainda quando a versão que está lá é diferente da versão que você está usando no momento. E fica ainda pior quando você não tem acesso ao código fonte da biblioteca que estiver utilizando.</p>

<p>Para nos ajudar, existe a macro <tt>source</tt>, que recebe como parâmetro o nome da função, sem aspas, e exibe o respectivo código fonte, quando possível.</p>

<p>Existem casos em que isso não é possível, como quando você tentar ler o fonte de uma forma especial ou de um código que foi compilado utilizando AOT (veremos isso em detalhes mais para frente).</p>

<p>Vamos exibir o código fonte da função <tt>+</tt>, responsável por somar dois ou mais números:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nf">source</span> <span class="nv">+</span><span class="p">)</span>
</span><span class='line'><span class="c1">; (defn +</span>
</span><span class='line'><span class="c1">;   &amp;ldquo;Returns the sum of nums. (+) returns 0. Does not auto-promote</span>
</span><span class='line'><span class="c1">;   longs, will throw on overflow. See also: +&amp;lsquo;&amp;rdquo;</span>
</span><span class='line'><span class="c1">;   {:inline (nary-inline &#39;add &#39;unchecked_add)</span>
</span><span class='line'><span class="c1">;    :inline-arities &gt;1?</span>
</span><span class='line'><span class="c1">;    :added &amp;ldquo;1.2&amp;rdquo;}</span>
</span><span class='line'><span class="c1">;   ([] 0)</span>
</span><span class='line'><span class="c1">;   ([x] (cast Number x))</span>
</span><span class='line'><span class="c1">;   ([x y] (. clojure.lang.Numbers (add x y)))</span>
</span><span class='line'><span class="c1">;   ([x y &amp;amp; more]</span>
</span><span class='line'><span class="c1">;      (reduce1 + (+ x y) more)))&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Note que temos acesso a todos os detalhes internos da função <tt>+</tt>, incluindo sua documentação e mais algumas informações que são úteis para o compilador ou para alguma função que gere documentação automaticamente.</p>

<p>Ao tentarmos ver o código fonte de uma forma especial ou de algum código escrito nativamente em Java, receberemos uma mensagem de que o código fonte não foi encontrado:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nf">source</span> <span class="nv">Thread/sleep</span><span class="p">)</span>
</span><span class='line'><span class="c1">; Source not found&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Há muito mais recursos no REPL do Clojure, inclusive no que diz respeito a integração com o seu editor preferido, mas vou deixar isso para outro artigo.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[QuickTips] Do Wordpress para Octopress/Jekyll no GitHub Pages]]></title>
    <link href="http://1up4dev.org/2013/09/quicktips-do-wordpress-para-octopress-slash-jekyll-no-github-pages/"/>
    <updated>2013-09-20T22:38:00-03:00</updated>
    <id>http://1up4dev.org/2013/09/quicktips-do-wordpress-para-octopress-slash-jekyll-no-github-pages</id>
    <content type="html"><![CDATA[<p>Quando migramos nosso blog do Wordpress para o GitHub Pages, escrevi um email para nossos autores com instruções resumidas para configurar e postar com Octopress/Jekyll. Percebi que dando um tapa nesse email, poderia publicá-lo aqui no blog como um guia rápido e talvez incentivar outros blogueiros a fazer o mesmo.</p>

<h2>Por que GitHub Pages?</h2>

<p>Corte de custos! Manter o blog no Wordpress requer um hosting, um banco de dados e um domínio. Reduzimos as despesas apenas para o registro de domínio (por enquanto).</p>

<p>Performance! GitHub Pages é estático, e conteúdo estático é servido naturalmente mais rápido.</p>

<p>Desafio! Estavamos &ldquo;acostumados&rdquo; ao Wordpress. Aprender Jekyll e a postar &ldquo;commitando em um projeto&rdquo; permite que tenhamos novas idéias, ou no pior dos casos, aprendamos novas tecnologias.</p>

<h2>Requisitos</h2>

<p>Para utilizar o GitHub Pages, crie um repositório com o nome <strong>usuariogithub.github.io</strong>, incluindo o &ldquo;github.io&rdquo;. O GitHub gerencia este repositório e publica o conteúdo estático no endereço <a href="http://usuariogithub.github.io">http://usuariogithub.github.io</a></p>

<p>Agora, para gerar o conteúdo estático vamos usar o <a href="http://octopress.org">Octopress</a>.</p>

<h2>Instalação</h2>

<p>Basta clonar o repositório do Octopress localmente:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git clone git@github.com:imathis/octopress.git
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>instalar as gems necessárias e em seguida rodar a rake para configuração:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>rake setup_github_pages
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>e informar o seu repositório do GitHub Pages:</p>

<pre><code>git@github.com:username/username.github.io.git
</code></pre>

<p>Pronto! Os remoting points do projeto serão configurados para seu repositório do GitHub, como segue:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>git remote -v&lt;/p&gt;
</span><span class='line'>
</span><span class='line'>&lt;p&gt;octopress   git@github.com:imathis/octopress.git <span class="o">(</span>fetch<span class="o">)</span>
</span><span class='line'>octopress   git@github.com:imathis/octopress.git <span class="o">(</span>push<span class="o">)</span>
</span><span class='line'>origin   git@github.com:username/username.github.io.git <span class="o">(</span>fetch<span class="o">)</span>
</span><span class='line'>origin   git@github.com:username/username.github.io.git <span class="o">(</span>push<span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h2>Postando</h2>

<p>Para criar um novo post, basta rodar a rake:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>rake new_post<span class="o">[</span>&amp;ldquo;o titulo <span class="k">do </span>seu post&amp;rdquo;<span class="o">]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>o que vai criar o arquivo <em>source/_posts/2013-09-17-o-titulo-do-seu-post.markdown</em>. Escreva o conteúdo do seu post normalmente em Markdown (recomendo utilizar o <a href="http://markup.herokuapp.com/">Markup Editor</a>) e execute:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>rake generate
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>para gerar o site estático no diretório <em>_deploy</em>. Caso queira dar um preview no que será publicado, basta rodar:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>rake preview
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>e acessar no browser <a href="http://localhost:4000.">http://localhost:4000.</a></p>

<h2>Publicando</h2>

<p>Quando terminar seu post, basta rodar:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nv">$ </span>rake deploy
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>para publicar o site no seu repositório do GitHub Pages.</p>

<p>Pronto! Não se esqueça de subir os fontes do site (branch source), commitando suas alterações e executando o classico <em>git push</em>.</p>

<h2>Migrando</h2>

<p>Caso já tenha um site publicado no Wordpress, você pode seguir este guia para importar todo o conteúdo na estrutura do Jekyll:</p>

<p><a href="http://johnnycode.com/2012/07/10/how-to-migrate-from-wordpress-to-jekyll-running-on-github/">How to Migrate from WordPress to Jekyll Running on Github</a></p>

<h2>Referências</h2>

<ul>
<li><a href="http://pages.github.com/">GitHub Pages</a></li>
<li><a href="http://octopress.org/">Octopress.org</a></li>
<li><a href="http://jekyllrb.com/">Jekyll</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Entendendo LISP, finalmente.]]></title>
    <link href="http://1up4dev.org/2013/07/entendendo-lisp-finalmente/"/>
    <updated>2013-07-14T11:35:31-03:00</updated>
    <id>http://1up4dev.org/2013/07/entendendo-lisp-finalmente</id>
    <content type="html"><![CDATA[<h2>A sintaxe invertida</h2>

<p>Ao olhar um código LISP pela primeira vez, você se assusta.</p>

<p>Eu me assustei e não havia ninguém para me ajudar a entender.</p>

<p>Que bom que você está lendo isto para entender bem depressa e perder o medo.</p>

<p>Acredite ou não, o LISP não é invertido: as outras linguagens é que são inconsistentes.</p>

<p>Matematicamente falando, funções são expressas dessa forma:</p>

<pre><code>y = f(x)
</code></pre>

<p>Para calcularmos o dobro de um número, teríamos:</p>

<pre><code>y = dobro(21)
</code></pre>

<p>Note que estamos usando uma notação diferente: primeiro vem o operador dobro e, em seguida, vem o operando, ou parâmetro, 21. Chamamos isso de notação prefixa.</p>

<p>Já para executar um cálculo matemático, usamos a forma abaixo:</p>

<pre><code>y = 21 * 2
</code></pre>

<p>Primeiro temos um operador 21, depois temos um operando responsável pela multiplicação e, finalmente, o segundo operando 2. Chamamos essa forma de notação infixa.</p>

<p>Nota: se você é um desenvolvedor Ruby, ignore essa última expressão. Em Ruby o cálculo acima utiliza internamente a notação prefixa onde 21 é um objeto, * é um método (ou uma mensagem, se preferir) e 2 é um parâmetro.</p>

<p>A coisa fica bagunçada quando misturamos as duas formas:</p>

<pre><code>y = dobro(7 * 3)
</code></pre>

<p>Na expressão acima misturamos notação prefixa com infixa. Não há problema algum com isso, mas não é um bom exemplo de consistência.</p>

<p>Quando falamos em LISP, o primeiro item de uma lista é um operador e todos os demais são operandos.</p>

<p>Todo operador é uma função, macro ou forma especial, inclusive os operadores matemáticos. Não se preocupe em entender agora o que são macros ou formas especiais. Todo o resto da lista é considerado um valor, parâmetro ou operando.</p>

<p>Imagine agora que o símbolo <code>+</code> é uma função. Para calcularmos uma soma usaríamos o seguinte código:</p>

<pre><code>+(1, 2)
</code></pre>

<p>Movendo os parênteses e removendo as vírgulas, a nossa soma inicial ficaria:</p>

<pre><code>(+ 1 2)
</code></pre>

<p>Sabemos que dobro também é uma função. Para calcular dobro, usaríamos:</p>

<pre><code>(dobro 12)
</code></pre>

<p>Percebam que agora temos uma regra que se aplica a todos os casos. Repetindo a expressão acima que mistura as notações infixa e prefixa usando as regras do LISP, teríamos:</p>

<pre><code>(dobro (+ 7 3))
</code></pre>

<p>Talvez pela sua origem acadêmica e fortemente influenciada pela matemática, as implementações de LISP levam muito a sério a questão da consistência.</p>

<h2>Os parênteses</h2>

<p>Quando eu estava na quarta série, aprendi uma coisa chamada <em>expressão numérica</em>, que consistia em resolver um cálculo extenso atacando um pedaço por vez, organizadamente.</p>

<p>Cada pedaço desse cálculo ficava dentro de parênteses, colchetes ou chaves, dependendo do quão aninhado estivesse a expressão. Eu nunca mais vi esse tipo de hierarquia,  mas era um jeito bacana de manter a organização.</p>

<p>Uma expressão numérica tem essa cara:</p>

<pre><code>x = {1 + [3 * (5 + 7)]}
</code></pre>

<p>Resolvemos a expressão de dentro para fora:</p>

<pre><code>x = {1 + [3 * (12)]}

x = {1 + [36]}

x = {37}

x = 37
</code></pre>

<p>Simples, não?</p>

<p>Agora vamos extrapolar o que aprendemos na quarta série para uma linguagem de programação, trocando chaves e colchetes por parênteses:</p>

<pre><code>x = (1 + (3 * (5 + 7)))
</code></pre>

<p>Vamos substituir a nossa conhecida notação infixa pela prefixa.</p>

<pre><code>x = (+ 1 (* 3 (+ 5 7)))
</code></pre>

<p>Pronto. Você tem uma expressão numérica com a cara do LISP, resolvendo da forma como a professora ensinou lá na quarta série: primeiro você resolve os parênteses de dentro, depois os próximos, até terminar.</p>

<p>Qualquer LISP que você encontrar pela frente, incluindo o Clojure, funciona exatamente dessa maneira.</p>

<p>Uma vantagem que isso traz é que você não precisa ficar se preocupando com precedência de operadores.</p>

<p>Imagine que você tem o código abaixo:</p>

<pre><code>x = 3 * 2 + 1

y = 1 + 2 * 3
</code></pre>

<p>Os valores de x e y serão iguais? Sim, ambas as variáveis contém o número 7, mas para saber disso você precisou ler em algum outro lugar que o operador de multiplicação tem precedência sobre o operador de adição. É algo que você espera que seja assim e age como se realmente fosse.</p>

<p>E o que aconteceria se você estiver usando uma linguagem em que a adição tem precedência sobre a multiplicação? Ou pior ainda: os operadores são executados da esquerda para a direita conforme forem aparecendo.</p>

<p>No primeiro caso, x e y continuariam sendo igual, mas ambos teriam o valor 9. No segundo caso, x seria igual a 7 e y seria igual a 9.</p>

<p>Seria mais fácil se as expressões fossem escritas assim:</p>

<pre><code>x = (3 * 2) + 1

y = 1 + (2 * 3)
</code></pre>

<p>Agora está claro para qualquer pessoa o que vai ser executado primeiro, independente do modo como a expressão seja interpretada pela linguagem. Pois saiba que é exatamente assim que um LISP trabalha. Usando a notação prefixa, as expressões acima ficariam:</p>

<pre><code>x = (+ (* 3 2) 1)

y = (+ 1 (* 3 2))
</code></pre>

<p>Primeiro será executada a multiplicação, que está nos parênteses mais internos e, em seguida, será executada a adição. Tudo isso sem se preocupar com regras ocultas ou peculiaridades do compilador.</p>

<p>Qualquer código em qualquer dialeto LISP, mesmo com suas características particulares, fica fácil de entender se você lembrar dessas regrinha.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[QuickTips] Usando Shell Script como suite de teste]]></title>
    <link href="http://1up4dev.org/2013/06/quicktips-usando-shell-script-como-suite-de-teste/"/>
    <updated>2013-06-27T09:42:18-03:00</updated>
    <id>http://1up4dev.org/2013/06/quicktips-usando-shell-script-como-suite-de-teste</id>
    <content type="html"><![CDATA[<p>Indo na linha do programador pragmático, às vezes, dependendo do time ou linguagem do projeto, é muito mais prático usar shell script para testar. Recentemente resolvi usar esta abordagem, e cheguei no seguinte &ldquo;template&rdquo; em shell script para testar uma API Server.</p>

<p>Dependências:</p>

<ul>
<li><p>bash</p></li>
<li><p>curl</p></li>
</ul>


<p>Foi testado no Ubuntu 13.04.</p>

<p>Obs: Vou embedar <a href="https://gist.github.com/rogerleite/5869576">este gist</a>, e pode ser que não apareça no seu reader ;D.</p>

<p>Obs2: Este post é uma versão pt-br deste post no coderwall <a href="https://coderwall.com/p/nsso8w">Using Shell Script to test your server</a>.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>test.sh </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>  <span class="c">#!/bin/bash</span>
</span><span class='line'>
</span><span class='line'><span class="nv">URL</span><span class="o">=</span>http://localhost:8080
</span><span class='line'>
</span><span class='line'><span class="c">## Unit-Testable Shell Scripts (http://eradman.com/posts/ut-shell-scripts.html)</span>
</span><span class='line'><span class="nb">typeset</span> -i <span class="nv">tests_run</span><span class="o">=</span>0
</span><span class='line'><span class="k">function </span>try <span class="o">{</span> <span class="nv">this</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>; <span class="o">}</span>
</span><span class='line'><span class="nb">trap</span> <span class="s1">&#39;printf &quot;$0: exit code $? on line $LINENO\nFAIL: $this\n&quot;; exit 1&#39;</span> ERR
</span><span class='line'><span class="k">function </span>assert <span class="o">{</span>
</span><span class='line'>    <span class="nb">let </span>tests_run+<span class="o">=</span>1
</span><span class='line'>    <span class="o">[</span> <span class="s2">&quot;$1&quot;</span> <span class="o">=</span> <span class="s2">&quot;$2&quot;</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="o">{</span> <span class="nb">echo</span> -n <span class="s2">&quot;.&quot;</span>; <span class="k">return</span>; <span class="o">}</span>
</span><span class='line'>    <span class="nb">printf</span> <span class="s2">&quot;\nFAIL: $this\n&#39;$1&#39; != &#39;$2&#39;\n&quot;</span>; <span class="nb">exit </span>1
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="c">## end</span>
</span><span class='line'>
</span><span class='line'><span class="c">###############################################################</span>
</span><span class='line'>
</span><span class='line'>try <span class="s2">&quot;Example of GET and test for 404 status&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">out</span><span class="o">=</span><span class="k">$(</span>curl -s -w <span class="s2">&quot;%{http_code}&quot;</span> <span class="nv">$URL</span><span class="k">)</span>
</span><span class='line'>assert <span class="s2">&quot;404&quot;</span> <span class="s2">&quot;$out&quot;</span>
</span><span class='line'>
</span><span class='line'>try <span class="s2">&quot;Example of POST XML&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Post xml (from hello.xml file) on /hello</span>
</span><span class='line'><span class="nv">out</span><span class="o">=</span><span class="k">$(</span>cat <span class="nb">test</span>/hello.xml | curl -s -H <span class="s2">&quot;Content-Type: text/xml&quot;</span> -d @- <span class="se">\</span>
</span><span class='line'>  -X POST <span class="nv">$URL</span>/hello<span class="k">)</span>
</span><span class='line'>assert <span class="s2">&quot;Hello World&quot;</span> <span class="s2">&quot;$out&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c">###############################################################</span>
</span><span class='line'><span class="nb">echo</span>
</span><span class='line'><span class="nb">echo</span> <span class="s2">&quot;PASS: $tests_run tests run&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Referências:</p>

<p><a href="http://eradman.com/posts/ut-shell-scripts.html">Unit-Testable Shell Scripts</a></p>

<p>Aguardo dicas, sugestões, experiências etc.</p>
]]></content>
  </entry>
  
</feed>
