<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | 1up4developers]]></title>
  <link href="http://1up4dev.org/categories/clojure/atom.xml" rel="self"/>
  <link href="http://1up4dev.org/"/>
  <updated>2014-09-24T01:11:14+00:00</updated>
  <id>http://1up4dev.org/</id>
  <author>
    <name><![CDATA[1up4developers]]></name>
    <email><![CDATA[1up4dev@googlegroups.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Fazendo mágica com o REPL do Clojure]]></title>
    <link href="http://1up4dev.org/2014/09/magica-com-o-repl-do-clojure/"/>
    <updated>2014-09-23T18:24:00+00:00</updated>
    <id>http://1up4dev.org/2014/09/magica-com-o-repl-do-clojure</id>
    <content type="html"><![CDATA[<p>Caso você não esteja íntimo com o REPL do Clojure, recomendo a leitura do <a href="http://1up4dev.org/2014/04/alguns-truques-com-o-repl-do-clojure/">texto anterior</a> para aprender o básico.</p>

<p>É recomendado também que você leia as mensagens emitidas pela aplicação com a voz do <a href="http://pt.wikipedia.org/wiki/Cid_Moreira">Cid Moreira</a>. Para uma versão em inglês do artigo estou considerando sugerir as vozes do Morgan Freeman ou do Stephen Fry.</p>

<p>As pessoas me perguntam se um REPL é equivalente ao IRB do Ruby ou o modo interativo do Python. No artigo anterior eu comentei que o REPL é bem mais do que isso, mas ainda não fui convincente o bastante.</p>

<p>Nesse artigo eu pretendo demonstrar como podemos modificar a aplicação enquanto ela é executada, sem necessidade de reiniciá-la ou de esperar para que a compilação termine.</p>

<p>Primeiro, vamos instalar uma ferramenta chamada <strong>Leiningen</strong>, que pode ser facilmente instalada a partir de <a href="http://leiningen.org/#install.">http://leiningen.org/#install.</a></p>

<p>O <strong>Leiningen</strong> é uma ferramenta que automatiza uma série de processos cotidianos do desenvolvimento de uma aplicação, além de também cuidar das dependências da aplicação. Pense nele como um primo bonito do <strong>Maven</strong> ou do <strong>Gradle</strong>.</p>

<p>Primeiro, vamos criar uma aplicação usando o <strong>Leiningen</strong>.</p>

<p>No terminal, digite:</p>

<pre><code>lein new misterm
</code></pre>

<p>Se for a primeira vez que você utiliza o <strong>Leiningen</strong>, algumas dependências serão baixadas para a sua máquina.</p>

<pre><code>$ lein new misterm
Generating a project called misterm based on the 'default' template.
The default template is intended for library projects, not applications.
To see other templates (app, plugin, etc), try `lein help new`.
</code></pre>

<p>Será criado um diretório chamado <code>misterm</code>, onde teremos nossa aplicação, e dentro desse diretório, edite um arquivo <code>project.clj</code>.</p>

<pre><code>; O seu arquivo project.clj vai ter essa cara
(defproject misterm "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]])
</code></pre>

<p>O conteúdo do arquivo <code>project.clj</code> nada mais é do que um código Clojure válido, sendo <code>defproject</code> uma <strong>macro</strong> que armazena as configurações do projeto em algum estado global. Vou deixar para explicar macros em outro artigo.</p>

<p>Para que a mágica funcione, vamos adicionar o <code>nREPL</code> na nossa aplicação. <code>nREPL</code> é uma biblioteca que permite que o REPL do Clojure seja acessado remotamente, normalmente através de uma porta TCP. O próprio REPL do Clojure disponibilizado pelo Leiningen já vem com o nREPL, como vamos ver mais para frente.</p>

<p>Para criarmos um projeto executável, precisamos informar no projeto em qual <strong>namespace</strong> estará o <strong>entrypoint</strong> da aplicação. Pense num <strong>namespace</strong> como um <strong>package</strong> do Java, apesar de existirem grandes diferenças entre ambos. Para a nossa explicação, considerar um como o outro basta.</p>

<p>Vamos editar o arquivo, adicionando a nova dependência dentro do vetor <code>:dependencies</code> e também a opção <code>:main misterm.core</code> antes do parêntese final.</p>

<p>O final do arquivo vai ficar assim:</p>

<pre><code>; final do arquivo project.clj
  :dependencies [[org.clojure/clojure "1.6.0"]
                 [org.clojure/tools.nrepl "0.2.5"]]
  :main misterm.core)
</code></pre>

<p>Agora vamos editar o arquivo <code>core.clj</code>, que está dentro de <code>src/misterm</code>. Perceba que o nome da aplicação é usado por padrão como parte do nome do <strong>namespace</strong>.</p>

<p>Encontraremos um arquivo assim:</p>

<pre><code>(ns misterm.core)

(defn foo
  "I don't do a whole lot."
  [x]
  (println x "Hello, World!"))
</code></pre>

<p>Aqui está sendo declarado o <strong>namespace</strong> <code>misterm.core</code>, e em seguida uma função <code>foo</code> que simplesmente imprime o texto <strong>Hello, World!</strong>.</p>

<p>Vamos modificar a declaração do <strong>namespace</strong> para que possamos usar o <code>nREPL</code> em nossa aplicação.</p>

<pre><code>(ns misterm.core
    (:require [clojure.tools.nrepl.server :as nrepl]))
</code></pre>

<p>Em seguida vamos iniciar o servidor do <code>nREPL</code> na porta 12345.</p>

<pre><code>(defonce server (nrepl/start-server :port 12345))
</code></pre>

<p>Estamos usando <code>defonce</code> aqui para garantir que, ao acessarmos a aplicação via <code>nREPL</code>, o servidor não seja iniciado mais de uma vez. Caso isso aconteça teremos um erro porque a porta 12345 já estará em uso.</p>

<p>Vamos apagar a função <code>foo</code> e vamos criar uma chamada <code>magic</code>:</p>

<pre><code>(defn magica []
  (Thread/sleep 2000)
  (println "Mostre-nos o seu segredo, Mister M"))
</code></pre>

<p>Nossa função simplesmente espera dois segundos e, sem seguida, imprime na tela um texto.</p>

<p>Agora vamos criar a função <code>-main</code>, que serve como <strong>entrypoint</strong> da aplicação, assim como o método <code>main</code> de uma aplicação Java.</p>

<pre><code>(defn -main [&amp; args]
  (loop []
    (magica)
    (recur)))
</code></pre>

<p>O argumento <code>&amp; args</code> indica que a função <code>-main</code> aceita uma quantidade indefinida de parâmetros, ou mesmo nenhum, exatamente como acontece com o método <code>main(String ... args)</code> do Java.</p>

<p>Os operadores <code>loop</code> e <code>recur</code> são usados para simularmos <strong>tail call recursion</strong> no Clojure, o que é assunto para outro texto. Para o que precisamos, basta saber que criamos um loop infinito com eles. Dentro desse loop infinito estamos invocando a função <code>magica</code>.</p>

<p>Tudo pronto, vamos salvar o arquivo e voltar para o terminal. Execute o comando <code>lein run</code> para executar a aplicação e a cada dois segundos será exibida a mensagem. Lembre-se de usar a voz do Cid Moreira ao ler.</p>

<pre><code>$ lein run
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
</code></pre>

<p>Vamos abrir um novo terminal e executar o comando <code>lein repl :connect 127.0.0.1:12345</code>.</p>

<pre><code>$ lein repl :connect 127.0.0.1:12345
Connecting to nREPL at 127.0.0.1:12345
REPL-y 0.3.5, nREPL 0.2.6
Clojure 1.6.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0-b132
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=&gt;
</code></pre>

<p>O prompt indica que estamos no namespace padrão do Clojure, chamado <code>user</code>. Vamos para o namespace onde estão as nossas funções para verificar se estamos mesmo conectados na aplicação.</p>

<pre><code>(ns misterm.core)
</code></pre>

<p>Agora vamos executar a função <code>magica</code>. Se tudo foi feito corretamente até agora, vamos esperar dois minutos e então ler a mensagem <strong>Mostre-nos o seu segredo, Mister M</strong>.</p>

<pre><code>(magica)
; Mostre-nos o seu segredo, Mister M
</code></pre>

<p>Tudo certo. Agora vamos modificar a aplicação enquanto ela está sendo executada.</p>

<p>Dê uma olhada no primeiro terminal. A essa altura a nossa mensagem já encheu a tela.</p>

<p>De volta ao segundo terminal, o que está com o REPL aberto, reescreva o conteúdo da função <code>magica</code>:</p>

<pre><code>(defn magica []
  (Thread/sleep 1000)
  (println "Aaaaaahhhhh, Mister M!"))
</code></pre>

<p>A função <code>magica</code> já existia, mas estamos redefinindo em tempo de execução. Se você tentar fazer isso no IRB, por exemplo, receberá uma mensagem de erro.</p>

<p>Agora olhe novamente no primeiro terminal, aquele que estava com a tela cheia de mensagens.</p>

<pre><code>Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Aaaaaahhhhh, Mister M!
Aaaaaahhhhh, Mister M!
Aaaaaahhhhh, Mister M!
</code></pre>

<p>A mensagem mudou! Não só isso. Agora ela leva um segundo para ser exibida na tela, ao invés dos dois originais. Nós mudamos a aplicação enquanto ela estava sendo executada.</p>

<p>Claro que toda mágica tem lá seus pontos a serem considerados. Se você reiniciar a aplicação a mensagem original será novamente exibida, já que alteramos a aplicação enquanto ela estava sendo executada, e não seu código fonte.</p>

<p>Esse recurso é muito útil para corrigir erros sem derrubar a aplicação, para desenvolver aplicações de maneira verdadeiramente incremental e iterativa, e também para aumentarmos a velocidade do ciclo de desenvolvimento ao máximo. Pense que dessa forma não precisamos mais derrubar a aplicação, recompilar, executar novamente, aguardar o tempo de carga da JVM, que não é pouco. Numa visão otimista, caso você ganhe dez segundos em cada iteração do seu ciclo de desenvolvimento, ao final do dia você terá economizado muito tempo, além de ter mantido o foco naquilo que realmente importa. É sabido que essas mudanças de contexto, por mais rápidas que sejam, atrapalham a concentração e a produtividade.</p>

<p>Editores como <strong>Emacs</strong> e <strong>ViM</strong> têm plugins que se conectam ao <code>nREPL</code>, fazendo com que você nem ao menos precise fechar a janela de edição de código para alterar a aplicação. Já o <strong>Lighttable</strong> oferece um modo chamado <strong>InstantREPL</strong>, onde seu código é avaliado na própria edição, exibindo os valores enquanto você programa.</p>

<p>O REPL é uma ferramenta poderosa não só no Clojure, mas em praticamente todos os dialetos LISP. Experimente fazer isso com a sua linguagem preferida e veja se consegue ter tanto ganho de produtividade.</p>

<p>P.S.: Jon Garret conseguiu inclusive corrigir um bug em um satélite em órbita graças ao uso do REPL. Leia mais <a href="http://www.flownet.com/gat/jpl-lisp.html">aqui</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Alguns truques com o REPL do Clojure]]></title>
    <link href="http://1up4dev.org/2014/04/alguns-truques-com-o-repl-do-clojure/"/>
    <updated>2014-04-25T11:21:00+00:00</updated>
    <id>http://1up4dev.org/2014/04/alguns-truques-com-o-repl-do-clojure</id>
    <content type="html"><![CDATA[<p>O <tt>REPL</tt> é uma das ferramentas mais úteis para se programar em Clojure. Se você está chegando do Ruby ou do Python está mais do que acostumado a usar o <tt>IRB</tt> ou o modo interativo do Python. Veremos no decorrer do capítulo que o REPL é bem mais do que um prompt da linguagem, que serve apenas para que instruções sejam testadas.</p>

<p>Existem alguns atalhos e funções auxiliares que tornam o uso do REPL bem mais produtivo. Por mais que escrever diretamente no REPL não seja tão confortável quando no seu editor preferido, algumas vezes isso acaba sendo necessário.</p>

<h3>Qual é mesmo o nome daquela função?</h3>

<p>As funções da biblioteca padrão do Clojure vem com um texto explicativo, onde você pode se situar sobre como utilizá-las.</p>

<p>Podemos pesquisar alguma palavra que estiver dentro desses textos para encontrar a função que queremos, mas não lembramos o nome. Para isso, usamos <tt>find-doc</tt>, seguido da palavra ou trecho de texto relacionado ao que queremos.</p>

<p>Vamos supor que eu esteja procurando algo sobre ::sockets::. Basta digitar <tt>(find-doc &ldquo;socket&rdquo;)</tt> no REPL.</p>

<pre><code>(find-doc "socket")
; -------------------------
; clojure.tools.nrepl/connect
; ([&amp; {:keys [port host transport-fn], :or {transport-fn
;  transport/bencode, host "localhost"}}])
;  Connects to a socket-based REPL at the given host (defaults to
;  localhost) and port, returning the Transport (by default clojure.

; e mais um monte de coisas
</code></pre>

<p>No nosso exemplo, encontramos a função <tt>connect</tt>, que está no namespace <tt>clojure.tools.nrepl</tt>.</p>

<p>Se você lembra de alguma parte do nome da função, então pode usar a função <tt>apropos</tt>, passando como parâmetros o trecho do nome ou uma expressão regular. Não se preocupe com expressões regulares agora, pois veremos esse assunto em detalhes mais para frente.</p>

<p>Vamos supor que eu esteja manipulando vetores e não lembre o nome da função, mas saiba que a estrutura chama-se <tt>vector</tt>:</p>

<pre><code>(apropos "vector")
; (vector-of vector vector? vector-zip)
</code></pre>

<p>E agora você pode usar a função <tt>doc</tt> para ver a documentação daquela que mais se parecer com o que você estiver procurando:</p>

<pre><code>(doc vector?)
; -------------------------
; clojure.core/vector?
; ([x])
;   Return true if x implements IPersistentVector
</code></pre>

<p>Existe uma variação de <tt>apropos</tt> chamada <tt>apropos-better</tt>, que informa também o namespace da função quando ela não estiver dentro do namespace <tt>clojure.core</tt> ou dentro do namespace em que você estiver no momento:</p>

<pre><code>(apropos-better "vector")
; (vector vector-of vector? clojure.zip/vector-zip)
</code></pre>

<h3>Um pouco de Bash na sua vida</h3>

<p>Quando você usa o REPL por dentro do Leiningen, alguns atalhos já conhecidos pelos usuários de Bash estão disponíveis, mesmo para quem está usando o Leiningen no Windows.</p>

<p>O primeiro deles é a tecla ::TAB::, que exibe os nomes de funções que começam com o que você já digitou.</p>

<p>Por exemplo, vou digitar <tt>map</tt> e pressionar ::TAB::</p>

<pre><code>(map
; map           map-indexed   map?          mapcat        mapv
</code></pre>

<p>Outra combinação que agiliza bastante o trabalho é a combinação ::Control L::, ou ::Command L:: se você estiver usando MacOS, que limpa os resultados das expressões anteriores e mantém apenas a expressão que você estiver digitando no momento.</p>

<p>Existe também a combinação ::Control R::, ou ::Command R::, que completa o que você estiver digitando usando o histórico de comandos do REPL. Pressionando essa combinação mais de uma vez vai alternar entre todas as combinações já utilizadas que contenham o texto que você já digitou.</p>

<p>Usar as setas ::para cima:: ou ::para baixo:: permite que você navegue nos comandos utilizados recentemente.</p>

<h3>Recuperando os últimos resultados</h3>

<p>Existem também símbolos especiais que guardam os resultados das últimas expressões e exceções. Eles são <tt><em>1</tt>, <tt></em>2</tt> e <tt><em>3</tt> para os valores e <tt></em>e</tt> para a última exceção, ou erro, que ocorreu:</p>

<pre><code>(+ 1 2)
; 3

(* 2 4)
; 8

(/ 8 2)
; 4

(println "Resultados anteriores:" *1 *2 *3)
; Resultados anteriores: 4 8 3

(/ 1 0)
; ArithmeticException Divide by zero

(println "Último erro:" *e)
; Último erro: #&lt;ArithmeticException java.lang.ArithmeticException:
;   Divide by zero&gt;
</code></pre>

<h3>Consultando o código fonte</h3>

<p>Algumas vezes é bom ter acesso ao código fonte de determinada função ou macro para que possamos entender melhor como ela funciona. Enquanto eu escrevia este artigo, fiz isso constantemente para descobrir como as coisas funcionam por baixo dos panos.</p>

<p>Infelizmente, nem sempre é simples ir até o site onde o código fonte do Clojure está disponível e procurar o arquivo em que aquela função está definida.</p>

<p>Pior ainda quando a versão que está lá é diferente da versão que você está usando no momento. E fica ainda pior quando você não tem acesso ao código fonte da biblioteca que estiver utilizando.</p>

<p>Para nos ajudar, existe a macro <tt>source</tt>, que recebe como parâmetro o nome da função, sem aspas, e exibe o respectivo código fonte, quando possível.</p>

<p>Existem casos em que isso não é possível, como quando você tentar ler o fonte de uma forma especial ou de um código que foi compilado utilizando AOT (veremos isso em detalhes mais para frente).</p>

<p>Vamos exibir o código fonte da função <tt>+</tt>, responsável por somar dois ou mais números:</p>

<pre><code>(source +)
; (defn +
;   "Returns the sum of nums. (+) returns 0. Does not auto-promote
;   longs, will throw on overflow. See also: +'"
;   {:inline (nary-inline 'add 'unchecked_add)
;    :inline-arities &gt;1?
;    :added "1.2"}
;   ([] 0)
;   ([x] (cast Number x))
;   ([x y] (. clojure.lang.Numbers (add x y)))
;   ([x y &amp; more]
;      (reduce1 + (+ x y) more)))
</code></pre>

<p>Note que temos acesso a todos os detalhes internos da função <tt>+</tt>, incluindo sua documentação e mais algumas informações que são úteis para o compilador ou para alguma função que gere documentação automaticamente.</p>

<p>Ao tentarmos ver o código fonte de uma forma especial ou de algum código escrito nativamente em Java, receberemos uma mensagem de que o código fonte não foi encontrado:</p>

<pre><code>(source Thread/sleep)
; Source not found
</code></pre>

<p>Há muito mais recursos no REPL do Clojure, inclusive no que diz respeito a integração com o seu editor preferido, mas vou deixar isso para outro artigo.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sowing the seeds of code]]></title>
    <link href="http://1up4dev.org/2013/09/sowing-the-seeds-of-code/"/>
    <updated>2013-09-25T23:08:00+00:00</updated>
    <id>http://1up4dev.org/2013/09/sowing-the-seeds-of-code</id>
    <content type="html"><![CDATA[<p>Seguindo a filosofia de <a href="http://1up4dev.org/2013/03/o-ano-em-que-eu-tirei-a-bunda-da-cadeira/">tirar a bunda da cadeira</a>, tive a oportunidade de falar em excelentes eventos esse ano, conhecer muita gente interessante e dar os primeiros passos no sentido de disseminar a linguagem Clojure no Brasil e organizar comunidades em São Paulo e no Rio de Janeiro.</p>

<h2>Coding Dojo</h2>

<p>Em Maio tive a honra de ter sido convidado a apresentar um coding dojo de Clojure na <a href="http://dasdad.com.br/">Das Dad</a>, que acabou tendo uma aceitação bem maior do que eu esperava.</p>

<p>Tirando o fato do trânsito de São Paulo ter me derrubado e me feito chegar atrasado, conseguimos dar uma boa olhada na linguagem e atiçar a curiosidade. Quem quiser dar uma olhada no que foi feito, o código está <a href="https://github.com/dasdad/dojo-5">no GitHub</a>.</p>

<h2>Anhanguera</h2>

<p>Ainda em Maio, Alexandre Borba e eu fomos convidados a palestrar na unidade de Osasco da Anhanguera Educacional. Borba apresentou os conceitos de Coding Dojo, Katas e o formato Randori para os alunos, enquanto eu apresentei conceitos de orientação a objetos com JavaScript.</p>

<p>Os organizadores do evento prepararam um espaço para os palestrantes atrás do palco que era muito melhor do que qualquer <em>camarim</em> que eu já tenha visto nas vezes em que toquei por aí.</p>

<p>Alguns alunos perguntaram sobre o uso de JavaScript no mercado de trabalho, o que me deu a certeza de que uma palestra menos técnica e mais focada na realidade deles teria sido melhor aproveitada.</p>

<h2>2º ENCATEC</h2>

<p>O pessoal da Adapti, empresa júnior encubada no CEUNES-UFES, em São Mateus-ES, me convidou para o Segundo Encontro Norte-Capixaba de Tecnologia.</p>

<p>Lá tive o prazer de assistir a palestra da Professora Mariella Berger, do projeto IARA, que apresentou o &ldquo;famoso carro que atropelou a Ana Maria Braga&rdquo; e o projeto da Universidade Federal do Espírito Santo que junta automatização, robótica, inteligência artificial, sistema de visão e mais um monte de coisas bacanas usando soluções de código aberto.</p>

<p>Tive a oportunidade também de dividir espaço com meus ídolos Álvaro Justen, o Turicas, que falou sobre software livre; Ricardo Valeriano, que fez uma apresentação hardcore sobre Paralelismo e Concorrência com Ruby; e Luiz Rocha apresentando conceitos de sistemas distribuídos.</p>

<p>Eu falei sobre as aplicações de programação funcional em ambientes corporativos, visto que os alunos da UFES &ldquo;aprendem&rdquo; programação funcional e Haskell logo no primeiro semestre de uma maneira bem deficiente.</p>

<p>Assim como aconteceu na Anhanguera, saí com a impressão de que um tema menos técnico teria sido melhor aproveitado pelos alunos. O fato dos alunos serem pagos com horas de atividades extra-curriculares também fez com que muitos estivessem ali obrigados, estando pouco interessados nos temas apresentados.</p>

<h2>TDC SP</h2>

<p>Em Julho tivemos a etapa de São Paulo do The Developers Conference, evento itinerante organizado pela GlobalCode.</p>

<p>Eu tive a oportunidade de apresentar a primeira palestra da trilha de JavaScript e HTML5, na Quarta-feira, e apresentei vários recursos menos conhecidos do JavaScript, além de ter sorteado uma cópia do meu livro.</p>

<p>Como eu utilizei o manjadíssimo recurso de usar animais para explicar herança, um dos presentes comentou depois, no Twitter, que acha idiota a analogia com animais, visto que ele nunca utilizou animais nos sistemas que já ajudou a desenvolver. Eu achei que seria desnecessário dizer, mas o problema aí mora no fato do colega não perceber que eu estava explicando um conceito de uma forma que qualquer pessoa possa entender. Uma vez que você entenda o conceito, você pode extrapolá-lo para a sua realidade, seja utilizando herança para definir Pessoas Físicas e Jurídicas, seja para definir classes fiscais e naturezas de operação da forma que for mais conveniente.</p>

<p>O ponto negativo ficou por conta da organização, que atrasou o início das palestras em pouco mais de uma hora, não apresentou justificativas nem um pedido de desculpas aos presentes.</p>

<p>No Domingo, último dia do evento, fui mentor de Clojure no Coding Dojo que aconteceu na trilha de Ruby. Ao mesmo tempo e na mesma sala havia máquinas com Clojure, Scala e Ruby para resolver o mesmo problema. Os participantes saiam de uma máquina e iam para outra, onde podiam ver as diferenças e características de cada uma das linguagens.</p>

<p>Fiquei feliz ao perceber que o Clojure causou uma boa impressão e, novamente, despertou o interesse.</p>

<h2>QCon SP</h2>

<p>O grande evento do ano para desenvolvedores, infelizmente, caiu nos mesmos dias do RubyConf, evento da Locaweb voltado para a comunidade Ruby e Rails. Ouvi coisas muito boas sobre o RubyConf desse ano, e foi uma pena que eu não estive por lá.</p>

<p>Como acontece todos os anos, o nível das palestras foi muito bom e, pela primeira vez, tive a honra de ter sido convidado para falar sobre Clojure na trilha &ldquo;Fronteiras do Desenvolvimento&rdquo;.</p>

<p>Para minha surpresa, a sala ficou lotada. Muita gente em pé, muita gente interessada e várias pessoas vieram falar comigo após a palestra para tirar dúvidas ou mesmo para contar suas experiências ao adotar Clojure em suas empresas.</p>

<p>Não tenho dúvidas de que, profissionalmente falando, esse foi o ponto alto do ano para mim. Só tenho a agradecer aos presentes e à organização pelo interesse e pela oportunidade.</p>

<p>O ponto negativo, e até certo ponto divertido, ficou por conta da novelinha criada por um dos palestrantes ao falar mal de SOA. Os representantes de um dos patrocinadores, que vendem consultoria no assunto, ao se sentirem ofendidos, iniciaram um festival de resmungos passivo-agressivos como se um bom diálogo fosse construído dessa forma. O evento em si e a organização nada tiveram a ver com isso, mas foi interessante acompanhar algumas reações e ver quem as pessoas realmente são quando o calo dói.</p>

<h2>(clj-sp)</h2>

<p>Entre um evento e outro, percebendo o interesse crescente na linguagem Clojure, resolvi chamar os desenvolvedores das listas Clojure Brasil e Clojure BR para participar do (clj-sp), o Grupo de Usuários Clojure no Brasil. Somos o primeiro grupo do tipo no Brasil e, por mais estranho que pareça, nosso primeiro encontro foi no Rio de Janeiro.</p>

<p>Organizado pelo nosso amigo Giuliani, sete desenvolvedores se reuniram num bar da Lapa, o equivalente carioca da Vila Madalena e trocamos experiências sobre o uso de programação funcional em geral e Clojure em particular em nossos respectivos trabalhos.</p>

<p>Dois dias depois tivemos o primeiro encontro em São Paulo, nas dependências da iMasters, contando com uma apresentação minha sobre a sintaxe do Clojure, Konrad Scorciapino falando sobre Datalog e Jonas Fagundes compartilhando sua experiência com Clojure em startups.</p>

<p>O auditório da iMasters ficou pequeno para tanta gente interessada e eu fiquei impressionado como apareceu muito mais gente do que eu estava esperando.</p>

<p>Dia 26 de Setembro, última Quinta-feira do mês, teremos o segundo encontro. Caso você tenha interesse, as informações estão em [<a href="http://www.meetup.com/clj-sp/">http://www.meetup.com/clj-sp/</a>].</p>

<h2>O que vem por aí</h2>

<ul>
<li><p>7masters JavaScript
Já 25 de Setembro será dia de 7masters de JavaScript na iMasters. Eu e mais seis especialistas vamos apresentar lightining talks de sete minutos sobre algum assunto bacana relacionado à linguagem. Acesse [setemasters.imasters.com.br/edicoes/javascript/] e compareça.</p></li>
<li><p>DevDay
Em outubro vou falar novamente sobre JavaScript no <a href="http://devday.devisland.com/">DevDay</a>, um evento muito bacana voltado para desenvolvedores de software que vai acontecer em Belo Horizonte.</p></li>
</ul>


<p>Vai ser uma chance bacana de conhecer vários desenvolvedores que eu admiro e aprender com quem realmente conhece do assunto.</p>

<ul>
<li>Programação funcional
E, finalizando, estou escrevendo meu segundo livro, mais focado em programação funcional e como isso pode salvar a sua pele no seu trabalho ou nos seus projetos pessoais. É um livro bem mais denso e especializado que o <a href="http://www.casadocodigo.com.br/products/livro-javascript-jquery">primeiro</a>, mas estou tentando manter o mesmo tom didático e fácil de assimilar.</li>
</ul>


<p>Esse ano está sendo <em>o ano da colheita</em> de tudo o que eu plantei em 2012 e, enquanto isso, estou me preparando para colher mais frutos no ano que vem. Vamos ver no que dá.</p>
]]></content>
  </entry>
  
</feed>
