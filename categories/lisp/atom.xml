<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lisp | 1up4developers]]></title>
  <link href="http://1up4dev.org/categories/lisp/atom.xml" rel="self"/>
  <link href="http://1up4dev.org/"/>
  <updated>2016-07-09T13:57:13-03:00</updated>
  <id>http://1up4dev.org/</id>
  <author>
    <name><![CDATA[1up4developers]]></name>
    <email><![CDATA[1up4dev@googlegroups.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Extraindo dados da Internet com Clojure]]></title>
    <link href="http://1up4dev.org/2014/10/extraindo_dados_da_internet_com_clojure/"/>
    <updated>2014-10-28T12:10:00-02:00</updated>
    <id>http://1up4dev.org/2014/10/extraindo_dados_da_internet_com_clojure</id>
    <content type="html"><![CDATA[<h2>O problema</h2>

<p>A Internet é um repositórios de dados gigantesco e frequentemente precisamos extrair algo que nos interessa de maneira automatizada. O grande problema é que esses dados normalmente são apresentados de forma não estruturada, e precisamos utilizar uma técnica chamada <em>scrapping</em>, que consiste em abrir uma página, carregar o HTML e navegar dentro desse código para extrair o que precisamos.</p>

<p>Com o uso das ferramentas certas isso não é complicado, mas pode ser trabalhoso e, uma vez que a página que você estiver lendo altere alguma coisa em sua estrutura, você terá que adaptar seu código às mudanças.</p>

<p>Vamos apresentar um exemplo simples, mas que vai te dar uma boa base de como extrair dados de uma página utilizando Clojure.</p>

<h2>Quem escreveu mais livros na Casa do Código?</h2>

<p>A Casa do Código é uma editora brasileira especializada em livros para desenvolvedores de software, empreendedores e webdesigners. Seus autores são profissionais conhecidos em suas respectivas áreas e precisamos saber quais deles escreveram mais livros.</p>

<p>Para isso, vamos abrir a página inicial da editora em <a href="http://www.casadocodigo.com.br/,">http://www.casadocodigo.com.br/,</a> que contém links para todos os livros publicados até o momento. Com esses links em mãos, vamos entrar em cada um deles e extrair os nomes dos autores para em seguida agrupá-los e apresentarmos o resultado.</p>

<h3>Como fazer</h3>

<blockquote><p>É necessário ter algum conhecimento de Clojure e Leiningen para poder acompanhar este post. Dê uma lida no texto <a href="http://1up4dev.org/2014/09/magica-com-o-repl-do-clojure/">Fazendo mágica com o REPL do Clojure</a> para aprender como criar um projeto.</p></blockquote>

<p>Vamos criar um projeto chamado <code>autores</code>, definir o namespace inicial e adicionar a biblioteca <em>Enlive</em>, que vai nos permitir extrair os dados que queremos de dentro do código HTML. O nosso arquivo project.clj vai ficar parecido com o exemplo abaixo:</p>

<pre><code>(defproject autores "0.1.0-SNAPSHOT"
  ; informações de licença e descrição do projeto

  :dependencies [[org.clojure/clojure "1.6.0"]
                 [enlive "1.1.5"]]
  :main autores.core)
</code></pre>

<p>Enlive é uma biblioteca criada por Christophe Grand, coautor de Clojure Programming, que permite que você gere código HTML escrevendo em Clojure, e permite também que você extraia textos de um arquivo HTML já existente.</p>

<p>Para utilizarmos o Enlive em nosso código, vamos referenciar as funções na nossa declaração de namespace. Vamos também adicionar o <em>Pretty Print</em> para exibir o resultado formatado e as bibliotecas do <em>clojure.string</em> para manipularmos o texto. Também vamos precisar importar a classe <code>java.net.URL</code> para tratarmos o endereço do site. Nosso código então começa assim:</p>

<pre><code>(ns autores.core
  (:require [clojure.pprint :as pp]
            [net.cgrand.enlive-html :as en]
            [clojure.string :as str])
  (:import  [java.net URL]))
</code></pre>

<p>O primeiro passo é varrer a página inicial da editora e extrair os links dos livros. Abrindo o código fonte da página, percebemos que ela tem a seguinte estrutura, que aqui está devidamente resumida para fins de apresentação:</p>

<pre><code>&lt;html&gt;
&lt;head&gt;
  &lt;!-- titulo, meta, etc --&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;nav&gt;
    &lt;!-- menu do topo --&gt;
  &lt;/nav&gt;
  &lt;section&gt;
    &lt;!-- links e imagens com os livros --&gt;
  &lt;/section&gt;
  &lt;footer&gt;
    &lt;!-- menu do rodapé --&gt;
  &lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>

<p>Visualmente, a página tem a aparência da imagem abaixo:</p>

<p><img src="/images/uploads/2014/10/cdc-parts.png" alt="/images/uploads/2014/10/cdc-parts.png" /></p>

<p>Felizmente a página está bem estruturada e todos os links que nos interessam estão dentro da área <code>section</code>, o que vai nos poupar trabalho.</p>

<p>Vamos criar uma função chamada <code>get-links</code>, que vai receber a URL do site em formato texto e vamos extrair todo o código HTML usando a função <code>html-resource</code> do Enlive.</p>

<pre><code>(defn- get-links [url]
  (en/html-resource (URL. url)))
</code></pre>

<p>Perceba que a função <code>html-resource</code> exige que você converta a URL de texto para um objeto <code>java.net.URL</code>, para só então o passarmos como parâmetro para o Enlive.</p>

<p>Para evitar que o encadeamento de muitas funções torne o código difícil de ler, vamos alterá-lo para utilizar o operador <code>-&gt;</code> e vamos guardar o resultado em um <em>binding</em> chamado <code>links</code>. Perceba que essa abordagem permite que possamos adicionar funções no final da lista de argumentos de <code>-&gt;</code> sem diminuir a legibilidade do código.</p>

<pre><code>(defn- get-links [url]
  (let [links (-&gt; url
                  URL.
                  en/html-resource)]
    (pp/pprint links)))
</code></pre>

<p>Vamos então usar a função <code>select</code>, também do Enlive, que recebe como argumento um <em>vector</em> com as tags que você deseja extrair. Nós queremos somente os links, formados pela tag <code>&lt;a&gt;&lt;/a&gt;</code>, que estão contidas entre <code>&lt;section&gt;</code> e <code>&lt;/section&gt;</code>.</p>

<pre><code>(defn- get-links [url]
  (let [links (-&gt; url
                  URL. 
                  en/html-resource
                  (en/select [:body :section :a]))]))
</code></pre>

<p>A função <code>select</code> vai nos retornar uma lista contendo um <em>map</em> para cada elemento HTML que obedecer aos nossos requisitos. Cada <em>map</em> tem um item <code>:attrs</code> que contém os atributos da tag HTML, incluindo a página para a qual o link está apontando. Ainda dentro da função <code>get-links</code>, vamos converter essa lista de mapas em uma lista que contenha apenas os endereços e para isso vamos usar a função <code>map</code>, que recebe como parâmetros a função que vai transformar cada item da lista e a lista a ser transformada. Para fins de didática, vamos suprimir o código que está dentro de <code>let</code>, para só no final da explicação mostrarmos a função completa.</p>

<pre><code>  (map #((% :attrs) :href) 
       links)
</code></pre>

<p>Agora nossa função está retornando uma lista de links como na listagem abaixo, devidamente resumida:</p>

<pre><code>("/products/livro-programador-apaixonado"
 "/products/livro-aspnet-mvc"
 "/products/livro-jpa-eficaz"
 "/products/livro-photoshop"
 "/products/colecao-frameworks-java"
 ...
 "/products/livro-ciencia-da-computacao-com-jogos"
 "/products/vale-presente")
</code></pre>

<p>Os links são relativos à URL da página inicial, então vamos adicionar o endereço que que foi passado para a função <code>get-links</code> para torná-los absolutos. Note que nessa lista existem links que não são de livros, mas de coleções e do vale presente. Podemos eliminá-los usando a função <code>filter</code>, que recebe como parâmetros uma função que retorna <code>true</code> ou <code>false</code> de acordo com cada item da lista, e a lista a ser filtrada que é passada como terceiro parâmetro. Os itens que fizerem a função retornar <code>true</code> ficam, e os demais não são incluidos.</p>

<pre><code>(filter
  #(. % contains "livro")
  (map #(str url ((% :attrs) :href)) 
       links))
</code></pre>

<p>E agora nossa função retorna os endereços absolutos de todos os livros da editora, conforme a listagem abaixo:</p>

<pre><code>("http://www.casadocodigo.com.br/products/livro-programador-apaixonado"
 "http://www.casadocodigo.com.br/products/livro-aspnet-mvc"
 "http://www.casadocodigo.com.br/products/livro-jpa-eficaz"
 "http://www.casadocodigo.com.br/products/livro-photoshop"
 ...
 "http://www.casadocodigo.com.br/products/livro-ciencia-da-computacao-com-jogos")
</code></pre>

<p>Agora que concluímos o primeiro passo da nossa pesquisa, vamos editar o código da nossa função <code>main</code> para que a função <code>get-links</code> seja chamada:</p>

<pre><code>(defn -main [&amp; args]
  (pp/pprint
    (get-links "http://www.casadocodigo.com.br")))
</code></pre>

<p>Vamos criar agora uma função chamada <code>get-author</code>, que vai receber cada um dos links e, usando as funções do Enlive que já conhecemos, vai extrair o nome do autor, ou dos autores, de cada um dos livros.</p>

<p>Os nomes dos autores ficam dentro de uma tag <code>span</code> marcada com a classe <code>product-author-link</code>. Mais uma vez o site bem construído nos ajuda na tarefa. Para pesquisarmos uma tag que esteja utilizando determinada classe, vamos separar tag e classe com um ponto final, como se fosse um arquivo CSS. Assim, o nosso <code>span</code> com a classe <code>product-author-link</code> vai virar <code>:span.product-author-link</code>. O código inicial não vai ficar muito diferente do que fizemos em <code>get-links</code>:</p>

<pre><code>(defn- get-author [url]
  (let [authors (-&gt; url
                    URL.
                    en/html-resource
                    (en/select [:span.product-author-link]))]
      (pp/pprint authors)))
</code></pre>

<p>Vamos usar o link do primeiro livro para testar. O resultado traz toda a informação da tag <code>span</code> dentro de um map que está dentro de uma lista, e não só o nome do autor.</p>

<pre><code>(get-author "http://www.casadocodigo.com.br/products/livro-programador-apaixonado")

({:tag :span,
  :attrs {:class "product-author-link"},
  :content
  ("\n          \n            Chad Fowler\n          \n        ")})
</code></pre>

<p>Novamente vamos suprimir o código que está dentro do <code>let</code> para não poluir o texto. Vamos selecionar o <em>map</em> que está dentro da lista usando a função <code>first</code> e, em seguida, utilizar somente o valor que está na chave <code>:content</code>:</p>

<pre><code>((first authors) :content)
</code></pre>

<p>O valor que estava em <code>:content</code> também é uma lista contendo o nome do autor. Além do nome do autor, o texto está poluído com quebras de linhas, simbolizado por <code>\n</code> e espaços em branco. Vamos utilizar a função <code>replace</code> do namespace <code>clojure.string</code> para remover esses caracteres indesejados. Essa função recebe como parâmetros o texto original, uma expressão regular indicando o que deve ser alterado e, por último, o texto a ser utilizado na alteração.</p>

<p>Vamos utilizar o operador <code>-&gt;</code> para facilitar a leitura:</p>

<pre><code>(-&gt; ((first authors) :content)
    first
    (str/replace #"(\n|  )" ""))
</code></pre>

<p>Ao executar a função, temos o nome do autor limpo e sem caracteres indesejados:</p>

<pre><code>(get-author "http://www.casadocodigo.com.br/products/livro-programador-apaixonado")
=&gt; "Chad Fowler"
</code></pre>

<p>Tudo certo quando estamos lidando com um livro escrito por apenas um autor, mas quando temos coautorias a nossa função já não faz o que é esperado. Por exemplo, no livro de ASP.NET MVC, nossa função retorna o autor como <code>Fabrício Sanchez e Márcio Fábio Althmann</code>, e no livro de Lógica de Programação temos <code>Paulo Silveira, Adriano Almeida</code>. Tanto <code>,</code> como <code>e</code> são usados para separar os nomes dos autores.
Vamos fazer a nossa função retornar um <em>vector</em> com os nomes dos autores separados utilizando a função <code>split</code>, do namespace <code>clojure.string</code>. Essa função recebe como argumentos o texto a ser dividido e uma expressão regular indicando onde o texto deve ser dividido:</p>

<pre><code>(-&gt; ((first authors) :content)
    first
    (str/replace #"(\n|  )" "")
    (str/split #"(, | e )"))
</code></pre>

<p>Agora temos os nomes dos autores separados corretamente dentro um <em>vector</em>, como no exemplo abaixo:</p>

<pre><code>(get-author "http://www.casadocodigo.com.br/products/livro-programacao")
=&gt; ["Paulo Silveira" "Adriano Almeida"]
</code></pre>

<p>Voltando à nossa função <code>-main</code>, vamos fazer com que a função <code>get-author</code> pega os autores de cada um dos links retornados pela função <code>get-links</code>. Vamos usar o operador <code>-&gt;&gt;</code> para deixar mais fácil de entender as transformações que estamos fazendo nos dados. A diferença para o <code>-&gt;</code> é que o operador <code>-&gt;&gt;</code> passa o resultado da expressão como último parâmetro da expressão seguinte, enquanto o operador <code>-&gt;</code> passa como primeiro. Isso é necessário para podermos passar a lista retornada por <code>get-links</code> para a função <code>map</code> da expressão seguinte:</p>

<pre><code>(defn -main [&amp; args]
  (pp/pprint
    (-&gt;&gt; "http://www.casadocodigo.com.br"
         get-links
         (map get-author))))
</code></pre>

<p>A nossa função <code>-main</code> retornou uma lista contendo vários <em>vector</em> com os nomes dos autores. Um livro com mais de um autor vai retornar um <em>vector</em> com mais de um nome.</p>

<pre><code>(["Chad Fowler"]
 ["Fabrício Sanchez" "Márcio Fábio Althmann"]
 ...
 ["Mauricio Tollin" "Rodrigo Gomes" "Anderson Leite"]
 ...
 ["André Backes"]
 ["Bruno Feijó" "Esteban Clua" "Flávio S. Correa da Silva"])
</code></pre>

<p>Vamos utilizar a função <code>flatten</code> para converter essa lista de <em>vectors</em> de diversos tamanhos em uma lista de uma dimensão. Isso vai nos permitir calcular quantas vezes cada nome aparece na lista por meio da função <code>frequencies</code>. Como cada vez que o nome aparece é um livro escrito por aquele autor, podemos entender que <code>frequencies</code> vai atribuir o número de livros que aquele autor tem publicado pela Casa do Código:</p>

<pre><code>(defn -main [&amp; args]
  (pp/pprint
    (-&gt;&gt; "http://www.casadocodigo.com.br"
         get-links
         (map get-author)
         flatten
         frequencies)))
</code></pre>

<p>Agora temos uma lista não ordenada com o nome do autor e a quantidade de livros publicados:</p>

<pre><code>{"Caio Ribeiro Pereira" 1,
 "Fabrício Sanchez" 1,
 "Alexandre Saudate" 2,
 "Chad Fowler" 1,
 ...
 "Gabriel Schade Cardoso" 1,
 "Guilherme Moreira" 1}
</code></pre>

<p>Nosso próximo passo é ordenar essa lista, deixando os autores com maior número de livros no topo. Para isso vamos usar a função <code>sort</code>, que permite que você informe uma função para selecionar o critério de ordenação, que no nosso caso vai ser a função <code>last</code>, que retorna o último item de uma lista, e também a função que vai ser usada para comparar um item com outro e definir quem vem primeiro, que nosso caso vai ser <code>&gt;</code>. No caso do <code>last</code>, convém deixar claro que vamos pegar o último item do que vai ser comparado. No caso de <code>"Caio Ribeiro Pereira" 1</code>, o último item é o número 1. Se quisessemos ordenar por nome, usariámos a função <code>first</code>.</p>

<p>Em seguida vamos dividir essa lista em <em>n</em> grupos, de acordo com a quantidade de livros publicados usando a função <code>partition-by</code>. No nosso exemplo teremos um grupo com autores que tenham dois livros publicados e outro com autores com apenas um livro. Como nos interessa apenas os autores que mais publicaram livros, vamos usar a função <code>first</code> para selecionarmos apenas o primeiro grupo. Com isso nosso código ficará assim:</p>

<pre><code>(defn -main [&amp; args]
  (pp/pprint
    (-&gt;&gt; "http://www.casadocodigo.com.br"
         get-links
         (map get-author)
         flatten
         frequencies
         (sort-by last &gt;)
         (partition-by last)
         first)))
</code></pre>

<p>Agora temos o resultado abaixo:</p>

<pre><code>(["Alexandre Saudate" 2]
 ["Sérgio Lopes" 2]
 ["Paulo Silveira" 2]
 ["Tárcio Zemel" 2]
 ["Anderson Leite" 2]
 ["Mauricio Aniche" 2]
 ["Gilliard Cordeiro" 2]
 ["Hébert Coelho" 2]
 ["Eduardo Guerra" 2]
 ["Rafael Steil" 2])
</code></pre>

<p>Agora que temos a lista dos maiores autores, vamos otimizar um o nosso código adicionando uma dose de processamento paralelo. Note que a função <code>get-links</code> retorna uma lista de endereços que é passada como parâmetro para a função <code>map</code>, que passa endereço por endereço para a função <code>get-author</code>, sequencialmente. Se trocarmos <code>map</code> por <code>pmap</code>, serão criadas threads que executarão <code>get-author</code> em paralelo, melhorando o tempo total do nosso código. A quantidade de thread criadas por <code>pmap</code> está diretamente ligada ao número de núcleos ou processadores que sua máquina tiver.</p>

<p>Porém, o uso de <code>pmap</code> pode trazer um problema: é comum que a aplicação fique congelada por até um minuto após a execução do <code>pmap</code> por conta de questões internas de timeout de threads e configurações do pool utilizado pelo Clojure. Para resolver isso, devemos solicitar ao Clojure que finalize todas as thread que não estiverem sendo usadas, liberando-as para que o programa possa ser encerrado. Para isso usamos a função <code>shutdown-agents</code> na última linha da função <code>-main</code>.</p>

<p>Agora temos o nosso código funcionando alguns segundos mais rápido e trazendo os autores que mais publicaram livros pela Casa do Código.</p>

<h3>Código completo</h3>

<pre><code>(ns autores.core
  (:require [clojure.pprint :as pp]
            [net.cgrand.enlive-html :as en]
            [clojure.string :as str])
  (:import  [java.net URL]))

(defn- get-links [url]
  (let [links (-&gt; url
                  URL. 
                  en/html-resource
                  (en/select [:body :section :a]))]
      (filter
        #(. % contains "livro")
        (map #(str url ((% :attrs) :href)) 
             links))))

(defn- get-author [url]
  (let [authors (-&gt; url
                    URL.
                    en/html-resource
                    (en/select [:span.product-author-link]))]
    (str/split
      (str/replace
        (first
          ((first authors) :content))
        #"(\n|  )" "")
      #"(, | e )")))

(defn -main [&amp; args]
  (println "Os autores com mais publicações na Casa do Código:")
  (pp/pprint
    (-&gt;&gt; "http://www.casadocodigo.com.br"
         get-links
         (pmap get-author)
         flatten
         frequencies
         (sort-by last &gt;)
         (partition-by last)
         first))
  (shutdown-agents))
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fazendo mágica com o REPL do Clojure]]></title>
    <link href="http://1up4dev.org/2014/09/magica-com-o-repl-do-clojure/"/>
    <updated>2014-09-23T18:24:00-03:00</updated>
    <id>http://1up4dev.org/2014/09/magica-com-o-repl-do-clojure</id>
    <content type="html"><![CDATA[<p>Caso você não esteja íntimo com o REPL do Clojure, recomendo a leitura do <a href="http://1up4dev.org/2014/04/alguns-truques-com-o-repl-do-clojure/">texto anterior</a> para aprender o básico.</p>

<p>É recomendado também que você leia as mensagens emitidas pela aplicação com a voz do <a href="http://pt.wikipedia.org/wiki/Cid_Moreira">Cid Moreira</a>. Para uma versão em inglês do artigo estou considerando sugerir as vozes do Morgan Freeman ou do Stephen Fry.</p>

<p>As pessoas me perguntam se um REPL é equivalente ao IRB do Ruby ou o modo interativo do Python. No artigo anterior eu comentei que o REPL é bem mais do que isso, mas ainda não fui convincente o bastante.</p>

<p>Nesse artigo eu pretendo demonstrar como podemos modificar a aplicação enquanto ela é executada, sem necessidade de reiniciá-la ou de esperar para que a compilação termine.</p>

<p>Primeiro, vamos instalar uma ferramenta chamada <strong>Leiningen</strong>, que pode ser facilmente instalada a partir de <a href="http://leiningen.org/#install.">http://leiningen.org/#install.</a></p>

<p>O <strong>Leiningen</strong> é uma ferramenta que automatiza uma série de processos cotidianos do desenvolvimento de uma aplicação, além de também cuidar das dependências da aplicação. Pense nele como um primo bonito do <strong>Maven</strong> ou do <strong>Gradle</strong>.</p>

<p>Primeiro, vamos criar uma aplicação usando o <strong>Leiningen</strong>.</p>

<p>No terminal, digite:</p>

<pre><code>lein new misterm
</code></pre>

<p>Se for a primeira vez que você utiliza o <strong>Leiningen</strong>, algumas dependências serão baixadas para a sua máquina.</p>

<pre><code>$ lein new misterm
Generating a project called misterm based on the 'default' template.
The default template is intended for library projects, not applications.
To see other templates (app, plugin, etc), try `lein help new`.
</code></pre>

<p>Será criado um diretório chamado <code>misterm</code>, onde teremos nossa aplicação, e dentro desse diretório, edite um arquivo <code>project.clj</code>.</p>

<pre><code>; O seu arquivo project.clj vai ter essa cara
(defproject misterm "0.1.0-SNAPSHOT"
  :description "FIXME: write description"
  :url "http://example.com/FIXME"
  :license {:name "Eclipse Public License"
            :url "http://www.eclipse.org/legal/epl-v10.html"}
  :dependencies [[org.clojure/clojure "1.6.0"]])
</code></pre>

<p>O conteúdo do arquivo <code>project.clj</code> nada mais é do que um código Clojure válido, sendo <code>defproject</code> uma <strong>macro</strong> que armazena as configurações do projeto em algum estado global. Vou deixar para explicar macros em outro artigo.</p>

<p>Para que a mágica funcione, vamos adicionar o <code>nREPL</code> na nossa aplicação. <code>nREPL</code> é uma biblioteca que permite que o REPL do Clojure seja acessado remotamente, normalmente através de uma porta TCP. O próprio REPL do Clojure disponibilizado pelo Leiningen já vem com o nREPL, como vamos ver mais para frente.</p>

<p>Para criarmos um projeto executável, precisamos informar no projeto em qual <strong>namespace</strong> estará o <strong>entrypoint</strong> da aplicação. Pense num <strong>namespace</strong> como um <strong>package</strong> do Java, apesar de existirem grandes diferenças entre ambos. Para a nossa explicação, considerar um como o outro basta.</p>

<p>Vamos editar o arquivo, adicionando a nova dependência dentro do vetor <code>:dependencies</code> e também a opção <code>:main misterm.core</code> antes do parêntese final.</p>

<p>O final do arquivo vai ficar assim:</p>

<pre><code>; final do arquivo project.clj
  :dependencies [[org.clojure/clojure "1.6.0"]
                 [org.clojure/tools.nrepl "0.2.5"]]
  :main misterm.core)
</code></pre>

<p>Agora vamos editar o arquivo <code>core.clj</code>, que está dentro de <code>src/misterm</code>. Perceba que o nome da aplicação é usado por padrão como parte do nome do <strong>namespace</strong>.</p>

<p>Encontraremos um arquivo assim:</p>

<pre><code>(ns misterm.core)

(defn foo
  "I don't do a whole lot."
  [x]
  (println x "Hello, World!"))
</code></pre>

<p>Aqui está sendo declarado o <strong>namespace</strong> <code>misterm.core</code>, e em seguida uma função <code>foo</code> que simplesmente imprime o texto <strong>Hello, World!</strong>.</p>

<p>Vamos modificar a declaração do <strong>namespace</strong> para que possamos usar o <code>nREPL</code> em nossa aplicação.</p>

<pre><code>(ns misterm.core
    (:require [clojure.tools.nrepl.server :as nrepl]))
</code></pre>

<p>Em seguida vamos iniciar o servidor do <code>nREPL</code> na porta 12345.</p>

<pre><code>(defonce server (nrepl/start-server :port 12345))
</code></pre>

<p>Estamos usando <code>defonce</code> aqui para garantir que, ao acessarmos a aplicação via <code>nREPL</code>, o servidor não seja iniciado mais de uma vez. Caso isso aconteça teremos um erro porque a porta 12345 já estará em uso.</p>

<p>Vamos apagar a função <code>foo</code> e vamos criar uma chamada <code>magic</code>:</p>

<pre><code>(defn magica []
  (Thread/sleep 2000)
  (println "Mostre-nos o seu segredo, Mister M"))
</code></pre>

<p>Nossa função simplesmente espera dois segundos e, sem seguida, imprime na tela um texto.</p>

<p>Agora vamos criar a função <code>-main</code>, que serve como <strong>entrypoint</strong> da aplicação, assim como o método <code>main</code> de uma aplicação Java.</p>

<pre><code>(defn -main [&amp; args]
  (loop []
    (magica)
    (recur)))
</code></pre>

<p>O argumento <code>&amp; args</code> indica que a função <code>-main</code> aceita uma quantidade indefinida de parâmetros, ou mesmo nenhum, exatamente como acontece com o método <code>main(String ... args)</code> do Java.</p>

<p>Os operadores <code>loop</code> e <code>recur</code> são usados para simularmos <strong>tail call recursion</strong> no Clojure, o que é assunto para outro texto. Para o que precisamos, basta saber que criamos um loop infinito com eles. Dentro desse loop infinito estamos invocando a função <code>magica</code>.</p>

<p>Tudo pronto, vamos salvar o arquivo e voltar para o terminal. Execute o comando <code>lein run</code> para executar a aplicação e a cada dois segundos será exibida a mensagem. Lembre-se de usar a voz do Cid Moreira ao ler.</p>

<pre><code>$ lein run
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
</code></pre>

<p>Vamos abrir um novo terminal e executar o comando <code>lein repl :connect 127.0.0.1:12345</code>.</p>

<pre><code>$ lein repl :connect 127.0.0.1:12345
Connecting to nREPL at 127.0.0.1:12345
REPL-y 0.3.5, nREPL 0.2.6
Clojure 1.6.0
Java HotSpot(TM) 64-Bit Server VM 1.8.0-b132
    Docs: (doc function-name-here)
          (find-doc "part-of-name-here")
  Source: (source function-name-here)
 Javadoc: (javadoc java-object-or-class-here)
    Exit: Control+D or (exit) or (quit)
 Results: Stored in vars *1, *2, *3, an exception in *e

user=&gt;
</code></pre>

<p>O prompt indica que estamos no namespace padrão do Clojure, chamado <code>user</code>. Vamos para o namespace onde estão as nossas funções para verificar se estamos mesmo conectados na aplicação.</p>

<pre><code>(ns misterm.core)
</code></pre>

<p>Agora vamos executar a função <code>magica</code>. Se tudo foi feito corretamente até agora, vamos esperar dois minutos e então ler a mensagem <strong>Mostre-nos o seu segredo, Mister M</strong>.</p>

<pre><code>(magica)
; Mostre-nos o seu segredo, Mister M
</code></pre>

<p>Tudo certo. Agora vamos modificar a aplicação enquanto ela está sendo executada.</p>

<p>Dê uma olhada no primeiro terminal. A essa altura a nossa mensagem já encheu a tela.</p>

<p>De volta ao segundo terminal, o que está com o REPL aberto, reescreva o conteúdo da função <code>magica</code>:</p>

<pre><code>(defn magica []
  (Thread/sleep 1000)
  (println "Aaaaaahhhhh, Mister M!"))
</code></pre>

<p>A função <code>magica</code> já existia, mas estamos redefinindo em tempo de execução. Se você tentar fazer isso no IRB, por exemplo, receberá uma mensagem de erro.</p>

<p>Agora olhe novamente no primeiro terminal, aquele que estava com a tela cheia de mensagens.</p>

<pre><code>Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Mostre-nos o seu segredo, Mister M
Aaaaaahhhhh, Mister M!
Aaaaaahhhhh, Mister M!
Aaaaaahhhhh, Mister M!
</code></pre>

<p>A mensagem mudou! Não só isso. Agora ela leva um segundo para ser exibida na tela, ao invés dos dois originais. Nós mudamos a aplicação enquanto ela estava sendo executada.</p>

<p>Claro que toda mágica tem lá seus pontos a serem considerados. Se você reiniciar a aplicação a mensagem original será novamente exibida, já que alteramos a aplicação enquanto ela estava sendo executada, e não seu código fonte.</p>

<p>Esse recurso é muito útil para corrigir erros sem derrubar a aplicação, para desenvolver aplicações de maneira verdadeiramente incremental e iterativa, e também para aumentarmos a velocidade do ciclo de desenvolvimento ao máximo. Pense que dessa forma não precisamos mais derrubar a aplicação, recompilar, executar novamente, aguardar o tempo de carga da JVM, que não é pouco. Numa visão otimista, caso você ganhe dez segundos em cada iteração do seu ciclo de desenvolvimento, ao final do dia você terá economizado muito tempo, além de ter mantido o foco naquilo que realmente importa. É sabido que essas mudanças de contexto, por mais rápidas que sejam, atrapalham a concentração e a produtividade.</p>

<p>Editores como <strong>Emacs</strong> e <strong>ViM</strong> têm plugins que se conectam ao <code>nREPL</code>, fazendo com que você nem ao menos precise fechar a janela de edição de código para alterar a aplicação. Já o <strong>Lighttable</strong> oferece um modo chamado <strong>InstantREPL</strong>, onde seu código é avaliado na própria edição, exibindo os valores enquanto você programa.</p>

<p>O REPL é uma ferramenta poderosa não só no Clojure, mas em praticamente todos os dialetos LISP. Experimente fazer isso com a sua linguagem preferida e veja se consegue ter tanto ganho de produtividade.</p>

<p>P.S.: Jon Garret conseguiu inclusive corrigir um bug em um satélite em órbita graças ao uso do REPL. Leia mais <a href="http://www.flownet.com/gat/jpl-lisp.html">aqui</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Alguns truques com o REPL do Clojure]]></title>
    <link href="http://1up4dev.org/2014/04/alguns-truques-com-o-repl-do-clojure/"/>
    <updated>2014-04-25T11:21:00-03:00</updated>
    <id>http://1up4dev.org/2014/04/alguns-truques-com-o-repl-do-clojure</id>
    <content type="html"><![CDATA[<p>O <tt>REPL</tt> é uma das ferramentas mais úteis para se programar em Clojure. Se você está chegando do Ruby ou do Python está mais do que acostumado a usar o <tt>IRB</tt> ou o modo interativo do Python. Veremos no decorrer do capítulo que o REPL é bem mais do que um prompt da linguagem, que serve apenas para que instruções sejam testadas.</p>

<p>Existem alguns atalhos e funções auxiliares que tornam o uso do REPL bem mais produtivo. Por mais que escrever diretamente no REPL não seja tão confortável quando no seu editor preferido, algumas vezes isso acaba sendo necessário.</p>

<h3>Qual é mesmo o nome daquela função?</h3>

<p>As funções da biblioteca padrão do Clojure vem com um texto explicativo, onde você pode se situar sobre como utilizá-las.</p>

<p>Podemos pesquisar alguma palavra que estiver dentro desses textos para encontrar a função que queremos, mas não lembramos o nome. Para isso, usamos <tt>find-doc</tt>, seguido da palavra ou trecho de texto relacionado ao que queremos.</p>

<p>Vamos supor que eu esteja procurando algo sobre <em>sockets</em>. Basta digitar <tt>(find-doc &ldquo;socket&rdquo;)</tt> no REPL.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">find-doc </span><span class="o">&amp;</span><span class="nv">ldquo</span><span class="c1">;socket&amp;rdquo;)</span>
</span><span class='line'><span class="c1">; &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;</span>
</span><span class='line'><span class="c1">; clojure.tools.nrepl/connect</span>
</span><span class='line'><span class="c1">; ([&amp;amp; {:keys [port host transport-fn], :or {transport-fn</span>
</span><span class='line'><span class="c1">;  transport/bencode, host &amp;ldquo;localhost&amp;rdquo;}}])</span>
</span><span class='line'><span class="c1">;  Connects to a socket-based REPL at the given host (defaults to</span>
</span><span class='line'><span class="c1">;  localhost) and port, returning the Transport (by default clojure.&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="c1">; e mais um monte de coisas&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>No nosso exemplo, encontramos a função <code>connect</code>, que está no namespace <code>clojure.tools.nrepl</code>.</p>

<p>Se você lembra de alguma parte do nome da função, então pode usar a função <tt>apropos</tt>, passando como parâmetros o trecho do nome ou uma expressão regular. Não se preocupe com expressões regulares agora, pois veremos esse assunto em detalhes mais para frente.</p>

<p>Vamos supor que eu esteja manipulando vetores e não lembre o nome da função, mas saiba que a estrutura chama-se <tt>vector</tt>:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nf">apropos</span> <span class="o">&amp;</span><span class="nv">ldquo</span><span class="c1">;vector&amp;rdquo;)</span>
</span><span class='line'><span class="c1">; (vector-of vector vector? vector-zip)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>E agora você pode usar a função <tt>doc</tt> para ver a documentação daquela que mais se parecer com o que você estiver procurando:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">doc </span><span class="nv">vector?</span><span class="p">)</span>
</span><span class='line'><span class="c1">; &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;</span>
</span><span class='line'><span class="c1">; clojure.core/vector?</span>
</span><span class='line'><span class="c1">; ([x])</span>
</span><span class='line'><span class="c1">;   Return true if x implements IPersistentVector&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Existe uma variação de <tt>apropos</tt> chamada <tt>apropos-better</tt>, que informa também o namespace da função quando ela não estiver dentro do namespace <tt>clojure.core</tt> ou dentro do namespace em que você estiver no momento:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nf">apropos-better</span> <span class="o">&amp;</span><span class="nv">ldquo</span><span class="c1">;vector&amp;rdquo;)</span>
</span><span class='line'><span class="c1">; (vector vector-of vector? clojure.zip/vector-zip)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>Um pouco de Bash na sua vida</h3>

<p>Quando você usa o REPL por dentro do Leiningen, alguns atalhos já conhecidos pelos usuários de Bash estão disponíveis, mesmo para quem está usando o Leiningen no Windows.</p>

<p>O primeiro deles é a tecla <em>TAB</em>, que exibe os nomes de funções que começam com o que você já digitou.</p>

<p>Por exemplo, vou digitar <tt>map</tt> e pressionar <em>TAB</em></p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nf">map</span>
</span><span class='line'><span class="c1">; map           map-indexed   map?          mapcat        mapv&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Outra combinação que agiliza bastante o trabalho é a combinação <em>Control L</em>, ou <em>Command L</em> se você estiver usando MacOS, que limpa os resultados das expressões anteriores e mantém apenas a expressão que você estiver digitando no momento.</p>

<p>Existe também a combinação <em>Control R</em>, ou <em>Command R</em>, que completa o que você estiver digitando usando o histórico de comandos do REPL. Pressionando essa combinação mais de uma vez vai alternar entre todas as combinações já utilizadas que contenham o texto que você já digitou.</p>

<p>Usar as setas <em>para cima</em> ou <em>para baixo</em> permite que você navegue nos comandos utilizados recentemente.</p>

<h3>Recuperando os últimos resultados</h3>

<p>Existem também símbolos especiais que guardam os resultados das últimas expressões e exceções. Eles são <tt><em>1</tt>, <tt></em>2</tt> e <tt><em>3</tt> para os valores e <tt></em>e</tt> para a última exceção, ou erro, que ocorreu:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">+ </span><span class="mi">1</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="c1">; 3&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">* </span><span class="mi">2</span> <span class="mi">4</span><span class="p">)</span>
</span><span class='line'><span class="c1">; 8&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">/ </span><span class="mi">8</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'><span class="c1">; 4&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">println </span><span class="o">&amp;</span><span class="nv">ldquo</span><span class="c1">;Resultados anteriores:&amp;rdquo; &lt;em&gt;1 &lt;/em&gt;2 *3)</span>
</span><span class='line'><span class="c1">; Resultados anteriores: 4 8 3&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">/ </span><span class="mi">1</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="c1">; ArithmeticException Divide by zero&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nb">println </span><span class="o">&amp;</span><span class="nv">ldquo</span><span class="c1">;Último erro:&amp;rdquo; *e)</span>
</span><span class='line'><span class="c1">; Último erro: #&lt;ArithmeticException java.lang.ArithmeticException:</span>
</span><span class='line'><span class="c1">;   Divide by zero&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>Consultando o código fonte</h3>

<p>Algumas vezes é bom ter acesso ao código fonte de determinada função ou macro para que possamos entender melhor como ela funciona. Enquanto eu escrevia este artigo, fiz isso constantemente para descobrir como as coisas funcionam por baixo dos panos.</p>

<p>Infelizmente, nem sempre é simples ir até o site onde o código fonte do Clojure está disponível e procurar o arquivo em que aquela função está definida.</p>

<p>Pior ainda quando a versão que está lá é diferente da versão que você está usando no momento. E fica ainda pior quando você não tem acesso ao código fonte da biblioteca que estiver utilizando.</p>

<p>Para nos ajudar, existe a macro <tt>source</tt>, que recebe como parâmetro o nome da função, sem aspas, e exibe o respectivo código fonte, quando possível.</p>

<p>Existem casos em que isso não é possível, como quando você tentar ler o fonte de uma forma especial ou de um código que foi compilado utilizando AOT (veremos isso em detalhes mais para frente).</p>

<p>Vamos exibir o código fonte da função <tt>+</tt>, responsável por somar dois ou mais números:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nf">source</span> <span class="nv">+</span><span class="p">)</span>
</span><span class='line'><span class="c1">; (defn +</span>
</span><span class='line'><span class="c1">;   &amp;ldquo;Returns the sum of nums. (+) returns 0. Does not auto-promote</span>
</span><span class='line'><span class="c1">;   longs, will throw on overflow. See also: +&amp;lsquo;&amp;rdquo;</span>
</span><span class='line'><span class="c1">;   {:inline (nary-inline &#39;add &#39;unchecked_add)</span>
</span><span class='line'><span class="c1">;    :inline-arities &gt;1?</span>
</span><span class='line'><span class="c1">;    :added &amp;ldquo;1.2&amp;rdquo;}</span>
</span><span class='line'><span class="c1">;   ([] 0)</span>
</span><span class='line'><span class="c1">;   ([x] (cast Number x))</span>
</span><span class='line'><span class="c1">;   ([x y] (. clojure.lang.Numbers (add x y)))</span>
</span><span class='line'><span class="c1">;   ([x y &amp;amp; more]</span>
</span><span class='line'><span class="c1">;      (reduce1 + (+ x y) more)))&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Note que temos acesso a todos os detalhes internos da função <tt>+</tt>, incluindo sua documentação e mais algumas informações que são úteis para o compilador ou para alguma função que gere documentação automaticamente.</p>

<p>Ao tentarmos ver o código fonte de uma forma especial ou de algum código escrito nativamente em Java, receberemos uma mensagem de que o código fonte não foi encontrado:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="nv">&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span><span class="p">(</span><span class="nf">source</span> <span class="nv">Thread/sleep</span><span class="p">)</span>
</span><span class='line'><span class="c1">; Source not found&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nv">&lt;p&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>Há muito mais recursos no REPL do Clojure, inclusive no que diz respeito a integração com o seu editor preferido, mas vou deixar isso para outro artigo.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Entendendo LISP, finalmente.]]></title>
    <link href="http://1up4dev.org/2013/07/entendendo-lisp-finalmente/"/>
    <updated>2013-07-14T11:35:31-03:00</updated>
    <id>http://1up4dev.org/2013/07/entendendo-lisp-finalmente</id>
    <content type="html"><![CDATA[<h2>A sintaxe invertida</h2>

<p>Ao olhar um código LISP pela primeira vez, você se assusta.</p>

<p>Eu me assustei e não havia ninguém para me ajudar a entender.</p>

<p>Que bom que você está lendo isto para entender bem depressa e perder o medo.</p>

<p>Acredite ou não, o LISP não é invertido: as outras linguagens é que são inconsistentes.</p>

<p>Matematicamente falando, funções são expressas dessa forma:</p>

<pre><code>y = f(x)
</code></pre>

<p>Para calcularmos o dobro de um número, teríamos:</p>

<pre><code>y = dobro(21)
</code></pre>

<p>Note que estamos usando uma notação diferente: primeiro vem o operador dobro e, em seguida, vem o operando, ou parâmetro, 21. Chamamos isso de notação prefixa.</p>

<p>Já para executar um cálculo matemático, usamos a forma abaixo:</p>

<pre><code>y = 21 * 2
</code></pre>

<p>Primeiro temos um operador 21, depois temos um operando responsável pela multiplicação e, finalmente, o segundo operando 2. Chamamos essa forma de notação infixa.</p>

<p>Nota: se você é um desenvolvedor Ruby, ignore essa última expressão. Em Ruby o cálculo acima utiliza internamente a notação prefixa onde 21 é um objeto, * é um método (ou uma mensagem, se preferir) e 2 é um parâmetro.</p>

<p>A coisa fica bagunçada quando misturamos as duas formas:</p>

<pre><code>y = dobro(7 * 3)
</code></pre>

<p>Na expressão acima misturamos notação prefixa com infixa. Não há problema algum com isso, mas não é um bom exemplo de consistência.</p>

<p>Quando falamos em LISP, o primeiro item de uma lista é um operador e todos os demais são operandos.</p>

<p>Todo operador é uma função, macro ou forma especial, inclusive os operadores matemáticos. Não se preocupe em entender agora o que são macros ou formas especiais. Todo o resto da lista é considerado um valor, parâmetro ou operando.</p>

<p>Imagine agora que o símbolo <code>+</code> é uma função. Para calcularmos uma soma usaríamos o seguinte código:</p>

<pre><code>+(1, 2)
</code></pre>

<p>Movendo os parênteses e removendo as vírgulas, a nossa soma inicial ficaria:</p>

<pre><code>(+ 1 2)
</code></pre>

<p>Sabemos que dobro também é uma função. Para calcular dobro, usaríamos:</p>

<pre><code>(dobro 12)
</code></pre>

<p>Percebam que agora temos uma regra que se aplica a todos os casos. Repetindo a expressão acima que mistura as notações infixa e prefixa usando as regras do LISP, teríamos:</p>

<pre><code>(dobro (+ 7 3))
</code></pre>

<p>Talvez pela sua origem acadêmica e fortemente influenciada pela matemática, as implementações de LISP levam muito a sério a questão da consistência.</p>

<h2>Os parênteses</h2>

<p>Quando eu estava na quarta série, aprendi uma coisa chamada <em>expressão numérica</em>, que consistia em resolver um cálculo extenso atacando um pedaço por vez, organizadamente.</p>

<p>Cada pedaço desse cálculo ficava dentro de parênteses, colchetes ou chaves, dependendo do quão aninhado estivesse a expressão. Eu nunca mais vi esse tipo de hierarquia,  mas era um jeito bacana de manter a organização.</p>

<p>Uma expressão numérica tem essa cara:</p>

<pre><code>x = {1 + [3 * (5 + 7)]}
</code></pre>

<p>Resolvemos a expressão de dentro para fora:</p>

<pre><code>x = {1 + [3 * (12)]}

x = {1 + [36]}

x = {37}

x = 37
</code></pre>

<p>Simples, não?</p>

<p>Agora vamos extrapolar o que aprendemos na quarta série para uma linguagem de programação, trocando chaves e colchetes por parênteses:</p>

<pre><code>x = (1 + (3 * (5 + 7)))
</code></pre>

<p>Vamos substituir a nossa conhecida notação infixa pela prefixa.</p>

<pre><code>x = (+ 1 (* 3 (+ 5 7)))
</code></pre>

<p>Pronto. Você tem uma expressão numérica com a cara do LISP, resolvendo da forma como a professora ensinou lá na quarta série: primeiro você resolve os parênteses de dentro, depois os próximos, até terminar.</p>

<p>Qualquer LISP que você encontrar pela frente, incluindo o Clojure, funciona exatamente dessa maneira.</p>

<p>Uma vantagem que isso traz é que você não precisa ficar se preocupando com precedência de operadores.</p>

<p>Imagine que você tem o código abaixo:</p>

<pre><code>x = 3 * 2 + 1

y = 1 + 2 * 3
</code></pre>

<p>Os valores de x e y serão iguais? Sim, ambas as variáveis contém o número 7, mas para saber disso você precisou ler em algum outro lugar que o operador de multiplicação tem precedência sobre o operador de adição. É algo que você espera que seja assim e age como se realmente fosse.</p>

<p>E o que aconteceria se você estiver usando uma linguagem em que a adição tem precedência sobre a multiplicação? Ou pior ainda: os operadores são executados da esquerda para a direita conforme forem aparecendo.</p>

<p>No primeiro caso, x e y continuariam sendo igual, mas ambos teriam o valor 9. No segundo caso, x seria igual a 7 e y seria igual a 9.</p>

<p>Seria mais fácil se as expressões fossem escritas assim:</p>

<pre><code>x = (3 * 2) + 1

y = 1 + (2 * 3)
</code></pre>

<p>Agora está claro para qualquer pessoa o que vai ser executado primeiro, independente do modo como a expressão seja interpretada pela linguagem. Pois saiba que é exatamente assim que um LISP trabalha. Usando a notação prefixa, as expressões acima ficariam:</p>

<pre><code>x = (+ (* 3 2) 1)

y = (+ 1 (* 3 2))
</code></pre>

<p>Primeiro será executada a multiplicação, que está nos parênteses mais internos e, em seguida, será executada a adição. Tudo isso sem se preocupar com regras ocultas ou peculiaridades do compilador.</p>

<p>Qualquer código em qualquer dialeto LISP, mesmo com suas características particulares, fica fácil de entender se você lembrar dessas regrinha.</p>
]]></content>
  </entry>
  
</feed>
