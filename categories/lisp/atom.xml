<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: lisp | 1up4developers]]></title>
  <link href="http://1up4dev.org/categories/lisp/atom.xml" rel="self"/>
  <link href="http://1up4dev.org/"/>
  <updated>2014-04-25T12:30:21-03:00</updated>
  <id>http://1up4dev.org/</id>
  <author>
    <name><![CDATA[1up4developers]]></name>
    <email><![CDATA[1up4dev@googlegroups.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Alguns truques com o REPL do Clojure]]></title>
    <link href="http://1up4dev.org/2014/04/alguns-truques-com-o-repl-do-clojure/"/>
    <updated>2014-04-25T11:21:00-03:00</updated>
    <id>http://1up4dev.org/2014/04/alguns-truques-com-o-repl-do-clojure</id>
    <content type="html"><![CDATA[<p>O <tt>REPL</tt> é uma das ferramentas mais úteis para se programar em Clojure. Se você está chegando do Ruby ou do Python está mais do que acostumado a usar o <tt>IRB</tt> ou o modo interativo do Python. Veremos no decorrer do capítulo que o REPL é bem mais do que um prompt da linguagem, que serve apenas para que instruções sejam testadas.</p>

<p>Existem alguns atalhos e funções auxiliares que tornam o uso do REPL bem mais produtivo. Por mais que escrever diretamente no REPL não seja tão confortável quando no seu editor preferido, algumas vezes isso acaba sendo necessário.</p>

<h3>Qual é mesmo o nome daquela função?</h3>

<p>As funções da biblioteca padrão do Clojure vem com um texto explicativo, onde você pode se situar sobre como utilizá-las.</p>

<p>Podemos pesquisar alguma palavra que estiver dentro desses textos para encontrar a função que queremos, mas não lembramos o nome. Para isso, usamos <tt>find-doc</tt>, seguido da palavra ou trecho de texto relacionado ao que queremos.</p>

<p>Vamos supor que eu esteja procurando algo sobre ::sockets::. Basta digitar <tt>(find-doc &ldquo;socket&rdquo;)</tt> no REPL.</p>

<pre><code>(find-doc "socket")
; -------------------------
; clojure.tools.nrepl/connect
; ([&amp; {:keys [port host transport-fn], :or {transport-fn
;  transport/bencode, host "localhost"}}])
;  Connects to a socket-based REPL at the given host (defaults to
;  localhost) and port, returning the Transport (by default clojure.

; e mais um monte de coisas
</code></pre>

<p>No nosso exemplo, encontramos a função <tt>connect</tt>, que está no namespace <tt>clojure.tools.nrepl</tt>.</p>

<p>Se você lembra de alguma parte do nome da função, então pode usar a função <tt>apropos</tt>, passando como parâmetros o trecho do nome ou uma expressão regular. Não se preocupe com expressões regulares agora, pois veremos esse assunto em detalhes mais para frente.</p>

<p>Vamos supor que eu esteja manipulando vetores e não lembre o nome da função, mas saiba que a estrutura chama-se <tt>vector</tt>:</p>

<pre><code>(apropos "vector")
; (vector-of vector vector? vector-zip)
</code></pre>

<p>E agora você pode usar a função <tt>doc</tt> para ver a documentação daquela que mais se parecer com o que você estiver procurando:</p>

<pre><code>(doc vector?)
; -------------------------
; clojure.core/vector?
; ([x])
;   Return true if x implements IPersistentVector
</code></pre>

<p>Existe uma variação de <tt>apropos</tt> chamada <tt>apropos-better</tt>, que informa também o namespace da função quando ela não estiver dentro do namespace <tt>clojure.core</tt> ou dentro do namespace em que você estiver no momento:</p>

<pre><code>(apropos-better "vector")
; (vector vector-of vector? clojure.zip/vector-zip)
</code></pre>

<h3>Um pouco de Bash na sua vida</h3>

<p>Quando você usa o REPL por dentro do Leiningen, alguns atalhos já conhecidos pelos usuários de Bash estão disponíveis, mesmo para quem está usando o Leiningen no Windows.</p>

<p>O primeiro deles é a tecla ::TAB::, que exibe os nomes de funções que começam com o que você já digitou.</p>

<p>Por exemplo, vou digitar <tt>map</tt> e pressionar ::TAB::</p>

<pre><code>(map
; map           map-indexed   map?          mapcat        mapv
</code></pre>

<p>Outra combinação que agiliza bastante o trabalho é a combinação ::Control L::, ou ::Command L:: se você estiver usando MacOS, que limpa os resultados das expressões anteriores e mantém apenas a expressão que você estiver digitando no momento.</p>

<p>Existe também a combinação ::Control R::, ou ::Command R::, que completa o que você estiver digitando usando o histórico de comandos do REPL. Pressionando essa combinação mais de uma vez vai alternar entre todas as combinações já utilizadas que contenham o texto que você já digitou.</p>

<p>Usar as setas ::para cima:: ou ::para baixo:: permite que você navegue nos comandos utilizados recentemente.</p>

<h3>Recuperando os últimos resultados</h3>

<p>Existem também símbolos especiais que guardam os resultados das últimas expressões e exceções. Eles são <tt><em>1</tt>, <tt></em>2</tt> e <tt><em>3</tt> para os valores e <tt></em>e</tt> para a última exceção, ou erro, que ocorreu:</p>

<pre><code>(+ 1 2)
; 3

(* 2 4)
; 8

(/ 8 2)
; 4

(println "Resultados anteriores:" *1 *2 *3)
; Resultados anteriores: 4 8 3

(/ 1 0)
; ArithmeticException Divide by zero

(println "Último erro:" *e)
; Último erro: #&lt;ArithmeticException java.lang.ArithmeticException:
;   Divide by zero&gt;
</code></pre>

<h3>Consultando o código fonte</h3>

<p>Algumas vezes é bom ter acesso ao código fonte de determinada função ou macro para que possamos entender melhor como ela funciona. Enquanto eu escrevia este livro, fiz isso constantemente para descobrir como as coisas funcionam por baixo dos panos.</p>

<p>Infelizmente, nem sempre é simples ir até o site onde o código fonte do Clojure está disponível e procurar o arquivo em que aquela função está definida.</p>

<p>Pior ainda quando a versão que está lá é diferente da versão que você está usando no momento. E fica ainda pior quando você não tem acesso ao código fonte da biblioteca que estiver utilizando.</p>

<p>Para nos ajudar, existe a macro <tt>source</tt>, que recebe como parâmetro o nome da função, sem aspas, e exibe o respectivo código fonte, quando possível.</p>

<p>Existem casos em que isso não é possível, como quando você tentar ler o fonte de uma forma especial ou de um código que foi compilado utilizando AOT (veremos isso em detalhes mais para frente).</p>

<p>Vamos exibir o código fonte da função <tt>+</tt>, responsável por somar dois ou mais números:</p>

<pre><code>(source +)
; (defn +
;   "Returns the sum of nums. (+) returns 0. Does not auto-promote
;   longs, will throw on overflow. See also: +'"
;   {:inline (nary-inline 'add 'unchecked_add)
;    :inline-arities &gt;1?
;    :added "1.2"}
;   ([] 0)
;   ([x] (cast Number x))
;   ([x y] (. clojure.lang.Numbers (add x y)))
;   ([x y &amp; more]
;      (reduce1 + (+ x y) more)))
</code></pre>

<p>Note que temos acesso a todos os detalhes internos da função <tt>+</tt>, incluindo sua documentação e mais algumas informações que são úteis para o compilador ou para alguma função que gere documentação automaticamente.</p>

<p>Ao tentarmos ver o código fonte de uma forma especial ou de algum código escrito nativamente em Java, receberemos uma mensagem de que o código fonte não foi encontrado:</p>

<pre><code>(source Thread/sleep)
; Source not found
</code></pre>

<p>Há muito mais recursos no REPL do Clojure, inclusive no que diz respeito a integração com o seu editor preferido, mas vou deixar isso para outro artigo.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Entendendo LISP, finalmente.]]></title>
    <link href="http://1up4dev.org/2013/07/entendendo-lisp-finalmente/"/>
    <updated>2013-07-14T11:35:31-03:00</updated>
    <id>http://1up4dev.org/2013/07/entendendo-lisp-finalmente</id>
    <content type="html"><![CDATA[<h2>A sintaxe invertida</h2>

<p>Ao olhar um código LISP pela primeira vez, você se assusta.</p>

<p>Eu me assustei e não havia ninguém para me ajudar a entender.</p>

<p>Que bom que você está lendo isto para entender bem depressa e perder o medo.</p>

<p>Acredite ou não, o LISP não é invertido: as outras linguagens é que são inconsistentes.</p>

<p>Matematicamente falando, funções são expressas dessa forma:</p>

<pre><code>y = f(x)
</code></pre>

<p>Para calcularmos o dobro de um número, teríamos:</p>

<pre><code>y = dobro(21)
</code></pre>

<p>Note que estamos usando uma notação diferente: primeiro vem o operador dobro e, em seguida, vem o operando, ou parâmetro, 21. Chamamos isso de notação prefixa.</p>

<p>Já para executar um cálculo matemático, usamos a forma abaixo:</p>

<pre><code>y = 21 * 2
</code></pre>

<p>Primeiro temos um operador 21, depois temos um operando responsável pela multiplicação e, finalmente, o segundo operando 2. Chamamos essa forma de notação infixa.</p>

<p>Nota: se você é um desenvolvedor Ruby, ignore essa última expressão. Em Ruby o cálculo acima utiliza internamente a notação prefixa onde 21 é um objeto, * é um método (ou uma mensagem, se preferir) e 2 é um parâmetro.</p>

<p>A coisa fica bagunçada quando misturamos as duas formas:</p>

<pre><code>y = dobro(7 * 3)
</code></pre>

<p>Na expressão acima misturamos notação prefixa com infixa. Não há problema algum com isso, mas não é um bom exemplo de consistência.</p>

<p>Quando falamos em LISP, o primeiro item de uma lista é um operador e todos os demais são operandos.</p>

<p>Todo operador é uma função, macro ou forma especial, inclusive os operadores matemáticos. Não se preocupe em entender agora o que são macros ou formas especiais. Todo o resto da lista é considerado um valor, parâmetro ou operando.</p>

<p>Imagine agora que o símbolo <code>+</code> é uma função. Para calcularmos uma soma usaríamos o seguinte código:</p>

<pre><code>+(1, 2)
</code></pre>

<p>Movendo os parênteses e removendo as vírgulas, a nossa soma inicial ficaria:</p>

<pre><code>(+ 1 2)
</code></pre>

<p>Sabemos que dobro também é uma função. Para calcular dobro, usaríamos:</p>

<pre><code>(dobro 12)
</code></pre>

<p>Percebam que agora temos uma regra que se aplica a todos os casos. Repetindo a expressão acima que mistura as notações infixa e prefixa usando as regras do LISP, teríamos:</p>

<pre><code>(dobro (+ 7 3))
</code></pre>

<p>Talvez pela sua origem acadêmica e fortemente influenciada pela matemática, as implementações de LISP levam muito a sério a questão da consistência.</p>

<h2>Os parênteses</h2>

<p>Quando eu estava na quarta série, aprendi uma coisa chamada <em>expressão numérica</em>, que consistia em resolver um cálculo extenso atacando um pedaço por vez, organizadamente.</p>

<p>Cada pedaço desse cálculo ficava dentro de parênteses, colchetes ou chaves, dependendo do quão aninhado estivesse a expressão. Eu nunca mais vi esse tipo de hierarquia,  mas era um jeito bacana de manter a organização.</p>

<p>Uma expressão numérica tem essa cara:</p>

<pre><code>x = {1 + [3 * (5 + 7)]}
</code></pre>

<p>Resolvemos a expressão de dentro para fora:</p>

<pre><code>x = {1 + [3 * (12)]}

x = {1 + [36]}

x = {37}

x = 37
</code></pre>

<p>Simples, não?</p>

<p>Agora vamos extrapolar o que aprendemos na quarta série para uma linguagem de programação, trocando chaves e colchetes por parênteses:</p>

<pre><code>x = (1 + (3 * (5 + 7)))
</code></pre>

<p>Vamos substituir a nossa conhecida notação infixa pela prefixa.</p>

<pre><code>x = (+ 1 (* 3 (+ 5 7)))
</code></pre>

<p>Pronto. Você tem uma expressão numérica com a cara do LISP, resolvendo da forma como a professora ensinou lá na quarta série: primeiro você resolve os parênteses de dentro, depois os próximos, até terminar.</p>

<p>Qualquer LISP que você encontrar pela frente, incluindo o Clojure, funciona exatamente dessa maneira.</p>

<p>Uma vantagem que isso traz é que você não precisa ficar se preocupando com precedência de operadores.</p>

<p>Imagine que você tem o código abaixo:</p>

<pre><code>x = 3 * 2 + 1

y = 1 + 2 * 3
</code></pre>

<p>Os valores de x e y serão iguais? Sim, ambas as variáveis contém o número 7, mas para saber disso você precisou ler em algum outro lugar que o operador de multiplicação tem precedência sobre o operador de adição. É algo que você espera que seja assim e age como se realmente fosse.</p>

<p>E o que aconteceria se você estiver usando uma linguagem em que a adição tem precedência sobre a multiplicação? Ou pior ainda: os operadores são executados da esquerda para a direita conforme forem aparecendo.</p>

<p>No primeiro caso, x e y continuariam sendo igual, mas ambos teriam o valor 9. No segundo caso, x seria igual a 7 e y seria igual a 9.</p>

<p>Seria mais fácil se as expressões fossem escritas assim:</p>

<pre><code>x = (3 * 2) + 1

y = 1 + (2 * 3)
</code></pre>

<p>Agora está claro para qualquer pessoa o que vai ser executado primeiro, independente do modo como a expressão seja interpretada pela linguagem. Pois saiba que é exatamente assim que um LISP trabalha. Usando a notação prefixa, as expressões acima ficariam:</p>

<pre><code>x = (+ (* 3 2) 1)

y = (+ 1 (* 3 2))
</code></pre>

<p>Primeiro será executada a multiplicação, que está nos parênteses mais internos e, em seguida, será executada a adição. Tudo isso sem se preocupar com regras ocultas ou peculiaridades do compilador.</p>

<p>Qualquer código em qualquer dialeto LISP, mesmo com suas características particulares, fica fácil de entender se você lembrar dessas regrinha.</p>
]]></content>
  </entry>
  
</feed>
